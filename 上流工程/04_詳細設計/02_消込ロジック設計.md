# 消込ロジック設計（AR/AP/CM）

| 項目 | 内容 |
|------|------|
| 文書番号 | DET-CLR-ACC-001 |
| 版数 | 1.0 |
| 作成日 | 2025/01/08 |
| 作成者 | システム設計チーム |
| 承認者 | |
| 承認日 | |

---

## 1. 消込処理概要

### 1.1 消込の種類

本システムでは、IT/コンサルティング事業およびアセットマネジメント（不動産・有価証券）事業の特性に応じた消込処理を実装する。

| 区分 | サブカテゴリ | 対象 | 消込パターン | 備考 |
|------|-------------|------|--------------|------|
| AR消込 | IT/コンサル | 売掛金（役務提供） | 請求書 × 入金 | マイルストーン請求対応 |
| AR消込 | 不動産 | 売掛金（賃料） | 賃料請求 × 入金 | 物件・テナント単位 |
| AR消込 | 不動産 | 預り敷金 | 敷金台帳 × 返還 | 契約終了時 |
| AR消込 | 有価証券 | 未収配当金 | 配当通知 × 入金 | 銘柄・権利日単位 |
| AP消込 | 共通 | 買掛金 | 請求書 × 支払 | 支払消込 |
| AP消込 | 不動産 | 預託敷金 | 敷金台帳 × 返還入金 | 解約時受領 |
| AP消込 | 有価証券 | 未払金（証券購入） | 約定 × 決済 | T+2/T+3決済 |
| CM消込 | 共通 | 預金残高 | 帳簿 × 銀行明細 | 銀行照合 |
| CM消込 | 有価証券 | 証券口座 | 帳簿 × 証券明細 | 証券照合 |

### 1.2 消込処理フロー

```
[AR消込フロー（入金消込）]

入金データ ─→ ┌──────────────────┐
（EB/手入力） │ 1. 取引先特定     │ ←─ 口座・振込人名
              └─────────┬────────┘
                        ▼
              ┌──────────────────┐
              │ 2. 消込候補検索   │ ←─ 未消込請求書/賃料/配当
              └─────────┬────────┘
                        ▼
              ┌──────────────────┐
              │ 3. 自動マッチング │ ←─ 消込優先ルール
              └─────────┬────────┘
                        ▼
              ┌──────────────────┐
              │ 4. 確信度判定     │
              └─────────┬────────┘
                        ▼
        ┌───────────────┴───────────────┐
        ▼                               ▼
┌───────────────┐               ┌───────────────┐
│ 高確信度       │               │ 低確信度       │
│ (自動消込)     │               │ (手動確認)     │
└───────┬───────┘               └───────┬───────┘
        │                               │
        ▼                               ▼
┌──────────────────┐             ┌──────────────────┐
│ 5. 差額処理      │             │ 5'. 担当者確認   │
│ (手数料/為替)    │             └─────────┬────────┘
└─────────┬────────┘                       │
          │         ┌─────────────────────┘
          ▼         ▼
        ┌──────────────────┐
        │ 6. 仕訳生成       │ ─→ 入金仕訳
        └─────────┬────────┘
                  ▼
        ┌──────────────────┐
        │ 7. 消込記録       │ ─→ 消込台帳・監査ログ
        └──────────────────┘
```

### 1.3 システム構成

```typescript
// 消込サービスアーキテクチャ
interface ClearingSystemArchitecture {
  // コアサービス
  services: {
    arClearingService: ARClearingService;      // AR消込サービス
    apClearingService: APClearingService;      // AP消込サービス
    cmReconciliationService: CMReconciliationService;  // CM照合サービス
    matchingEngine: MatchingEngine;            // マッチングエンジン
    differenceHandler: DifferenceHandler;      // 差額処理
    journalGenerator: JournalGeneratorService; // 仕訳生成
  };

  // 業種別モジュール
  industryModules: {
    consultingModule: ConsultingClearingModule;  // IT/コンサル
    propertyModule: PropertyClearingModule;       // 不動産
    securitiesModule: SecuritiesClearingModule;   // 有価証券
  };

  // 外部連携
  integrations: {
    ebDataReceiver: EBDataReceiver;      // EB入金データ受信
    bankApiClient: BankAPIClient;        // 銀行API
    securitiesApiClient: SecuritiesAPIClient; // 証券会社API
  };
}
```

---

## 2. 消込優先ルール

### 2.1 AR消込優先ルール（共通）

| 優先度 | ルール名 | 条件 | 適用場面 | 確信度 |
|--------|----------|------|----------|--------|
| 1 | 消込指示番号一致 | 入金摘要に消込ID含む | 指定入金 | 100% |
| 2 | 請求番号完全一致 | 振込依頼人欄に請求番号 | 番号指定入金 | 95% |
| 3 | 金額・取引先完全一致 | 入金額 = 請求残高（1件） | 全額入金 | 90% |
| 4 | 金額完全一致（複数候補） | 入金額 = 請求残高（複数） | 候補選択必要 | 70% |
| 5 | 取引先一致・合計金額一致 | 入金額 = Σ請求残高 | 一括入金 | 80% |
| 6 | 先入先出（FIFO） | 請求日が古い順 | 部分入金 | 60% |
| 7 | 期日優先 | 支払期日が近い順 | 期日管理 | 60% |

### 2.2 AR消込優先ルール（不動産）

| 優先度 | ルール名 | 条件 | 適用場面 | 確信度 |
|--------|----------|------|----------|--------|
| 1 | 物件・区画・月度一致 | 物件CD+区画+対象年月 | 定額賃料 | 95% |
| 2 | テナント口座一致 | 登録口座からの振込 | 定期振込 | 90% |
| 3 | 金額・物件一致 | 入金額 = 月額賃料 | 賃料入金 | 85% |
| 4 | 共益費込み金額一致 | 入金額 = 賃料 + 共益費 | 一括入金 | 80% |
| 5 | 敷金返還金額一致 | 入金額 = 預託敷金残高 | 解約返還 | 75% |

### 2.3 AR消込優先ルール（有価証券）

| 優先度 | ルール名 | 条件 | 適用場面 | 確信度 |
|--------|----------|------|----------|--------|
| 1 | 配当金額・銘柄一致 | 配当通知書金額と一致 | 配当入金 | 95% |
| 2 | 売却約定・決済日一致 | 約定金額×数量=入金額 | 売却決済 | 90% |
| 3 | 利金・償還金一致 | 債券利払・償還予定と一致 | 債券利金 | 90% |

### 2.4 AP消込優先ルール

| 優先度 | ルール名 | 条件 | 適用場面 |
|--------|----------|------|----------|
| 1 | 支払番号指定 | 支払データに請求書ID含む | FB支払 |
| 2 | 支払バッチ指定 | 支払バッチで対象選択済み | 自動支払 |
| 3 | 期日到来 | 支払期日 ≤ 支払実行日 | 期日支払 |
| 4 | 先入先出（FIFO） | 請求受領日が古い順 | 複数請求 |

### 2.5 消込ロジック詳細（TypeScript実装）

```typescript
// ============================================================
// 消込サービス インターフェース定義
// ============================================================

interface Receipt {
  receiptId: string;
  receiptDate: Date;
  accountId: string;                    // 入金口座
  amount: Decimal;                      // 入金額
  amountBase: Decimal;                  // 基軸通貨換算額
  currency: CurrencyCode;
  exchangeRate: Decimal;
  payerName: string;                    // 振込依頼人名
  payerAccountNo?: string;              // 振込元口座
  reference?: string;                   // 摘要・参照番号
  customerId?: string;                  // 特定済み取引先
  receiptType: 'EB_IMPORT' | 'MANUAL' | 'API';
  status: 'UNPROCESSED' | 'MATCHED' | 'PARTIAL' | 'CLEARED' | 'SUSPENDED';
}

interface ClearingCandidate {
  documentType: 'INVOICE' | 'RENT' | 'DIVIDEND' | 'DEPOSIT' | 'SETTLEMENT';
  documentId: string;
  customerId: string;
  customerName: string;
  documentDate: Date;
  dueDate: Date;
  totalAmount: Decimal;
  openAmount: Decimal;                  // 未消込残高
  currency: CurrencyCode;
  amountBase: Decimal;

  // 業種別属性
  propertyCode?: string;                // 不動産: 物件コード
  unitCode?: string;                    // 不動産: 区画コード
  targetMonth?: string;                 // 不動産: 対象年月
  securityCode?: string;                // 有価証券: 銘柄コード
  recordDate?: Date;                    // 有価証券: 権利確定日
  projectCode?: string;                 // IT/コンサル: プロジェクトコード
}

interface MatchResult {
  candidate: ClearingCandidate;
  matchScore: number;                   // 0-100
  matchReason: MatchReason[];
  clearAmount: Decimal;
  isAutoApprovable: boolean;            // 自動承認可否
}

type MatchReason =
  | 'CLEARING_ID_MATCH'           // 消込指示番号一致
  | 'INVOICE_NO_MATCH'            // 請求番号一致
  | 'AMOUNT_EXACT_MATCH'          // 金額完全一致
  | 'AMOUNT_TOTAL_MATCH'          // 合計金額一致
  | 'CUSTOMER_MATCH'              // 取引先一致
  | 'ACCOUNT_MATCH'               // 口座一致
  | 'PROPERTY_UNIT_MATCH'         // 物件・区画一致
  | 'SECURITY_DIVIDEND_MATCH'     // 配当一致
  | 'FIFO_APPLIED';               // FIFO適用

interface ClearingRecord {
  clearingId: string;
  receiptId: string;
  documentType: string;
  documentId: string;
  clearAmount: Decimal;
  clearAmountBase: Decimal;
  clearDate: Date;
  clearType: 'AUTO' | 'MANUAL' | 'PARTIAL' | 'REVERSAL';
  matchScore: number;
  matchReasons: MatchReason[];
  status: 'ACTIVE' | 'REVERSED';
  createdBy: string;
  createdAt: Date;
  reversedAt?: Date;
  reversedBy?: string;
  reversalReason?: string;
}

// ============================================================
// AR消込サービス実装
// ============================================================

class ARClearingService {
  private matchingEngine: MatchingEngine;
  private differenceHandler: DifferenceHandler;
  private journalGenerator: JournalGeneratorService;
  private clearingRepository: ClearingRepository;
  private auditLogger: AuditLogger;

  constructor(
    matchingEngine: MatchingEngine,
    differenceHandler: DifferenceHandler,
    journalGenerator: JournalGeneratorService,
    clearingRepository: ClearingRepository,
    auditLogger: AuditLogger
  ) {
    this.matchingEngine = matchingEngine;
    this.differenceHandler = differenceHandler;
    this.journalGenerator = journalGenerator;
    this.clearingRepository = clearingRepository;
    this.auditLogger = auditLogger;
  }

  /**
   * 入金消込メイン処理
   */
  async processReceipt(receipt: Receipt): Promise<ClearingResult> {
    const context = new ClearingContext(receipt);

    try {
      // 1. 取引先特定
      const customer = await this.identifyCustomer(receipt);
      if (!customer) {
        return this.handleUnidentifiedReceipt(receipt);
      }
      context.setCustomer(customer);

      // 2. 消込候補取得
      const candidates = await this.getClearingCandidates(customer, receipt);
      if (candidates.length === 0) {
        return this.handleNoCandidates(receipt, customer);
      }

      // 3. マッチング実行
      const matchResults = await this.matchingEngine.match(receipt, candidates);

      // 4. 確信度に基づく処理分岐
      const autoApprovable = matchResults.filter(r => r.isAutoApprovable);
      const manualRequired = matchResults.filter(r => !r.isAutoApprovable);

      if (autoApprovable.length > 0) {
        // 5a. 自動消込実行
        return await this.executeAutoClearing(receipt, autoApprovable, context);
      } else if (manualRequired.length > 0) {
        // 5b. 手動確認キューへ
        return await this.queueForManualReview(receipt, manualRequired, context);
      } else {
        // 5c. 候補なし
        return this.handleNoMatch(receipt, context);
      }

    } catch (error) {
      await this.auditLogger.logError('AR_CLEARING', receipt.receiptId, error);
      throw error;
    }
  }

  /**
   * 自動消込実行
   */
  private async executeAutoClearing(
    receipt: Receipt,
    matchResults: MatchResult[],
    context: ClearingContext
  ): Promise<ClearingResult> {
    let remainingAmount = receipt.amount;
    const clearings: ClearingRecord[] = [];
    const journalLines: JournalLine[] = [];

    // マッチスコア降順でソート
    const sortedResults = matchResults.sort((a, b) => b.matchScore - a.matchScore);

    for (const result of sortedResults) {
      if (remainingAmount.isLessThanOrEqualTo(0)) break;

      // 消込金額決定
      const clearAmount = Decimal.min(remainingAmount, result.clearAmount);

      // 消込レコード作成
      const clearing = await this.createClearing(
        receipt,
        result.candidate,
        clearAmount,
        result
      );
      clearings.push(clearing);

      // 仕訳明細生成
      const lines = await this.generateClearingJournalLines(
        receipt,
        result.candidate,
        clearAmount,
        context
      );
      journalLines.push(...lines);

      // 残額更新
      remainingAmount = remainingAmount.minus(clearAmount);

      // 消込対象ステータス更新
      await this.updateDocumentStatus(result.candidate, clearAmount);
    }

    // 残額処理（過入金/差額）
    if (!remainingAmount.isZero()) {
      const diffResult = await this.differenceHandler.handleDifference(
        receipt,
        remainingAmount,
        context
      );
      journalLines.push(...diffResult.journalLines);
    }

    // 仕訳生成
    const journal = await this.journalGenerator.generateJournal({
      journalType: 'AR_RECEIPT',
      journalDate: receipt.receiptDate,
      lines: journalLines,
      reference: receipt.receiptId,
      description: `入金消込 ${receipt.payerName}`,
      sourceSystem: 'AR_CLEARING'
    });

    // 監査ログ
    await this.auditLogger.log({
      action: 'AR_AUTO_CLEARING',
      documentId: receipt.receiptId,
      details: {
        clearings: clearings.map(c => c.clearingId),
        journalId: journal.journalId,
        totalCleared: receipt.amount.minus(remainingAmount).toString()
      }
    });

    return {
      status: 'CLEARED',
      receipt,
      clearings,
      journal,
      remainingAmount
    };
  }

  /**
   * 消込レコード作成
   */
  private async createClearing(
    receipt: Receipt,
    candidate: ClearingCandidate,
    clearAmount: Decimal,
    matchResult: MatchResult
  ): Promise<ClearingRecord> {
    const clearing: ClearingRecord = {
      clearingId: generateClearingId(),
      receiptId: receipt.receiptId,
      documentType: candidate.documentType,
      documentId: candidate.documentId,
      clearAmount,
      clearAmountBase: this.convertToBaseCurrency(clearAmount, receipt.currency, receipt.exchangeRate),
      clearDate: receipt.receiptDate,
      clearType: matchResult.isAutoApprovable ? 'AUTO' : 'MANUAL',
      matchScore: matchResult.matchScore,
      matchReasons: matchResult.matchReason,
      status: 'ACTIVE',
      createdBy: 'SYSTEM',
      createdAt: new Date()
    };

    return await this.clearingRepository.save(clearing);
  }

  /**
   * 取引先特定
   */
  private async identifyCustomer(receipt: Receipt): Promise<Customer | null> {
    // 1. 口座番号から特定
    if (receipt.payerAccountNo) {
      const customer = await this.customerRepository.findByBankAccount(receipt.payerAccountNo);
      if (customer) return customer;
    }

    // 2. 振込依頼人名から特定
    const customerByName = await this.customerRepository.findByPayerName(receipt.payerName);
    if (customerByName) return customerByName;

    // 3. 摘要から請求番号抽出して特定
    const invoiceNo = this.extractInvoiceNumber(receipt.reference);
    if (invoiceNo) {
      const invoice = await this.invoiceRepository.findByNumber(invoiceNo);
      if (invoice) {
        return await this.customerRepository.findById(invoice.customerId);
      }
    }

    // 4. 既存入金履歴から推定
    const historicalMatch = await this.findHistoricalMatch(receipt);
    if (historicalMatch) return historicalMatch;

    return null;
  }

  /**
   * 消込候補取得
   */
  private async getClearingCandidates(
    customer: Customer,
    receipt: Receipt
  ): Promise<ClearingCandidate[]> {
    const candidates: ClearingCandidate[] = [];

    // 未消込請求書
    const invoices = await this.invoiceRepository.findOpenInvoices(customer.customerId);
    candidates.push(...invoices.map(inv => this.toClearingCandidate(inv, 'INVOICE')));

    // 未消込賃料（不動産の場合）
    if (customer.businessType === 'PROPERTY') {
      const rents = await this.rentRepository.findOpenRents(customer.customerId);
      candidates.push(...rents.map(r => this.toClearingCandidate(r, 'RENT')));
    }

    // 未収配当金（有価証券の場合）
    if (customer.businessType === 'SECURITIES') {
      const dividends = await this.dividendRepository.findUnreceivedDividends(customer.customerId);
      candidates.push(...dividends.map(d => this.toClearingCandidate(d, 'DIVIDEND')));
    }

    return candidates;
  }
}

// ============================================================
// マッチングエンジン実装
// ============================================================

class MatchingEngine {
  private rules: MatchingRule[];
  private industryMatchers: Map<string, IndustryMatcher>;

  constructor() {
    this.rules = this.initializeRules();
    this.industryMatchers = new Map([
      ['PROPERTY', new PropertyMatcher()],
      ['SECURITIES', new SecuritiesMatcher()],
      ['CONSULTING', new ConsultingMatcher()]
    ]);
  }

  /**
   * マッチング実行
   */
  async match(
    receipt: Receipt,
    candidates: ClearingCandidate[]
  ): Promise<MatchResult[]> {
    const results: MatchResult[] = [];

    for (const candidate of candidates) {
      const matchResult = await this.evaluateCandidate(receipt, candidate);
      if (matchResult.matchScore > 0) {
        results.push(matchResult);
      }
    }

    // スコア降順でソート
    return results.sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * 候補評価
   */
  private async evaluateCandidate(
    receipt: Receipt,
    candidate: ClearingCandidate
  ): Promise<MatchResult> {
    let score = 0;
    const reasons: MatchReason[] = [];

    // 1. 消込指示番号チェック（最優先）
    if (this.hasClearingIdMatch(receipt, candidate)) {
      score = 100;
      reasons.push('CLEARING_ID_MATCH');
      return this.buildResult(candidate, score, reasons, receipt.amount, true);
    }

    // 2. 請求番号チェック
    if (this.hasInvoiceNumberMatch(receipt, candidate)) {
      score += 40;
      reasons.push('INVOICE_NO_MATCH');
    }

    // 3. 金額チェック
    const amountMatchResult = this.checkAmountMatch(receipt, candidate);
    score += amountMatchResult.score;
    if (amountMatchResult.reason) {
      reasons.push(amountMatchResult.reason);
    }

    // 4. 取引先チェック
    if (receipt.customerId === candidate.customerId) {
      score += 20;
      reasons.push('CUSTOMER_MATCH');
    }

    // 5. 業種別マッチング
    const industryMatcher = this.industryMatchers.get(candidate.documentType);
    if (industryMatcher) {
      const industryResult = await industryMatcher.evaluate(receipt, candidate);
      score += industryResult.score;
      reasons.push(...industryResult.reasons);
    }

    // 自動承認可否判定
    const isAutoApprovable = score >= 80 && reasons.includes('AMOUNT_EXACT_MATCH');

    // 消込金額決定
    const clearAmount = Decimal.min(receipt.amount, candidate.openAmount);

    return this.buildResult(candidate, score, reasons, clearAmount, isAutoApprovable);
  }

  /**
   * 金額マッチチェック
   */
  private checkAmountMatch(
    receipt: Receipt,
    candidate: ClearingCandidate
  ): { score: number; reason?: MatchReason } {
    // 完全一致
    if (receipt.amount.equals(candidate.openAmount)) {
      return { score: 35, reason: 'AMOUNT_EXACT_MATCH' };
    }

    // 入金額が残高以下（部分入金可能）
    if (receipt.amount.isLessThan(candidate.openAmount)) {
      return { score: 15 };
    }

    // 入金額が残高超（過入金）
    return { score: 5 };
  }

  /**
   * 消込指示番号マッチ
   */
  private hasClearingIdMatch(receipt: Receipt, candidate: ClearingCandidate): boolean {
    if (!receipt.reference) return false;

    // 摘要から消込IDパターン抽出
    const clearingIdPattern = /CLR-\d{8}-\d{6}/;
    const match = receipt.reference.match(clearingIdPattern);
    if (match && match[0] === candidate.documentId) {
      return true;
    }
    return false;
  }

  /**
   * マッチング結果構築
   */
  private buildResult(
    candidate: ClearingCandidate,
    score: number,
    reasons: MatchReason[],
    clearAmount: Decimal,
    isAutoApprovable: boolean
  ): MatchResult {
    return {
      candidate,
      matchScore: Math.min(score, 100),
      matchReason: reasons,
      clearAmount,
      isAutoApprovable
    };
  }
}
```

---

## 3. 差額処理

### 3.1 差額の種類と許容範囲

| 差額種類 | 発生要因 | 許容範囲 | 自動処理 | 振替先科目 |
|----------|----------|----------|----------|------------|
| 振込手数料（得意先負担） | 振込手数料控除 | 0〜1,100円 | ○ | 支払手数料 |
| 振込手数料（当社負担） | 予定外の手数料 | 0〜660円 | △ | 支払手数料 |
| 源泉徴収税 | 報酬源泉 | 計算値±10円 | ○ | 預り金（源泉税） |
| 早期支払割引 | 早期入金インセンティブ | 請求額の2%以内 | △ | 売上値引 |
| 端数値引 | 端数切捨て | 100円未満 | ○ | 雑収入/雑損失 |
| 為替差額 | 外貨入金時レート差 | 制限なし | ○ | 為替差損益 |
| 過入金 | 入金額 > 請求額 | 制限なし | △ | 前受金 |
| 不足入金 | 入金額 < 請求額 | 請求額の5%以内 | △ | 部分消込 |
| 消費税端数差 | 計算方法差異 | ±10円 | ○ | 雑収入/雑損失 |

※ ○:完全自動、△:条件付き自動（閾値超過時は手動確認）

### 3.2 差額処理ロジック

```typescript
// ============================================================
// 差額処理サービス
// ============================================================

interface DifferenceResult {
  differenceType: DifferenceType;
  originalAmount: Decimal;
  differenceAmount: Decimal;
  journalLines: JournalLine[];
  requiresManualReview: boolean;
  reviewReason?: string;
}

type DifferenceType =
  | 'BANK_FEE'           // 振込手数料
  | 'WITHHOLDING_TAX'    // 源泉徴収税
  | 'EARLY_PAYMENT_DISCOUNT' // 早期支払割引
  | 'ROUNDING'           // 端数
  | 'FX_DIFFERENCE'      // 為替差額
  | 'OVERPAYMENT'        // 過入金
  | 'UNDERPAYMENT'       // 不足入金
  | 'TAX_ROUNDING';      // 消費税端数

class DifferenceHandler {
  private config: DifferenceConfig;

  constructor(config: DifferenceConfig) {
    this.config = config;
  }

  /**
   * 差額処理メイン
   */
  async handleDifference(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): Promise<DifferenceResult> {
    const journalLines: JournalLine[] = [];
    let requiresManualReview = false;
    let reviewReason: string | undefined;

    // 差額なし
    if (difference.isZero()) {
      return {
        differenceType: 'ROUNDING',
        originalAmount: receipt.amount,
        differenceAmount: difference,
        journalLines: [],
        requiresManualReview: false
      };
    }

    const diffType = await this.identifyDifferenceType(receipt, difference, context);

    switch (diffType) {
      case 'BANK_FEE':
        return this.handleBankFee(receipt, difference, context);

      case 'WITHHOLDING_TAX':
        return this.handleWithholdingTax(receipt, difference, context);

      case 'FX_DIFFERENCE':
        return this.handleFxDifference(receipt, difference, context);

      case 'OVERPAYMENT':
        return this.handleOverpayment(receipt, difference, context);

      case 'UNDERPAYMENT':
        return this.handleUnderpayment(receipt, difference, context);

      case 'ROUNDING':
        return this.handleRounding(receipt, difference, context);

      default:
        return this.handleUnknownDifference(receipt, difference, context);
    }
  }

  /**
   * 差額種類の識別
   */
  private async identifyDifferenceType(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): Promise<DifferenceType> {
    const absDiff = difference.abs();

    // 1. 為替取引の場合
    if (receipt.currency !== 'JPY') {
      return 'FX_DIFFERENCE';
    }

    // 2. 源泉徴収の可能性チェック（IT/コンサル）
    if (context.customer.businessType === 'CONSULTING') {
      const expectedWithholding = await this.calculateExpectedWithholding(context);
      if (absDiff.minus(expectedWithholding).abs().isLessThanOrEqualTo(10)) {
        return 'WITHHOLDING_TAX';
      }
    }

    // 3. 振込手数料チェック（マイナス差額）
    if (difference.isNegative() && absDiff.isLessThanOrEqualTo(1100)) {
      return 'BANK_FEE';
    }

    // 4. 端数差額チェック
    if (absDiff.isLessThanOrEqualTo(100)) {
      return 'ROUNDING';
    }

    // 5. 過入金/不足入金
    if (difference.isPositive()) {
      return 'OVERPAYMENT';
    } else {
      return 'UNDERPAYMENT';
    }
  }

  /**
   * 振込手数料処理
   */
  private handleBankFee(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    const feeAmount = difference.abs();

    // 許容範囲チェック
    const maxAllowedFee = this.config.maxBankFee || new Decimal(1100);
    const requiresReview = feeAmount.isGreaterThan(maxAllowedFee);

    const journalLines: JournalLine[] = [{
      lineNo: 1,
      drCr: 'D',
      accountCode: '76200',  // 支払手数料
      accountName: '支払手数料',
      amount: feeAmount,
      taxCode: 'I10',        // 課税仕入10%
      description: '振込手数料（得意先負担）',
      segmentPC: context.customer.profitCenter,
      segmentCC: context.customer.costCenter
    }];

    return {
      differenceType: 'BANK_FEE',
      originalAmount: receipt.amount,
      differenceAmount: difference,
      journalLines,
      requiresManualReview: requiresReview,
      reviewReason: requiresReview ? `振込手数料が許容上限(${maxAllowedFee}円)を超過` : undefined
    };
  }

  /**
   * 源泉徴収税処理
   */
  private handleWithholdingTax(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    const taxAmount = difference.abs();

    // 期待源泉税額との差異チェック
    const expectedTax = this.calculateExpectedWithholding(context);
    const taxDiff = taxAmount.minus(expectedTax).abs();
    const requiresReview = taxDiff.isGreaterThan(10);

    const journalLines: JournalLine[] = [{
      lineNo: 1,
      drCr: 'C',
      accountCode: '21500',  // 預り金
      subAccountCode: 'WHT',  // 源泉徴収税
      accountName: '預り金（源泉税）',
      amount: taxAmount,
      taxCode: 'XX',         // 対象外
      description: '源泉所得税',
      segmentPC: context.customer.profitCenter
    }];

    return {
      differenceType: 'WITHHOLDING_TAX',
      originalAmount: receipt.amount,
      differenceAmount: difference,
      journalLines,
      requiresManualReview: requiresReview,
      reviewReason: requiresReview ? `源泉税額の差異(${taxDiff}円)が許容範囲外` : undefined
    };
  }

  /**
   * 為替差額処理
   */
  private handleFxDifference(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    const isGain = difference.isPositive();

    const journalLines: JournalLine[] = [{
      lineNo: 1,
      drCr: isGain ? 'C' : 'D',
      accountCode: isGain ? '79100' : '79200',  // 為替差益/為替差損
      accountName: isGain ? '為替差益' : '為替差損',
      amount: difference.abs(),
      taxCode: 'XX',         // 対象外
      description: `為替差${isGain ? '益' : '損'}（入金時換算）`,
      currency: receipt.currency,
      exchangeRate: receipt.exchangeRate,
      segmentPC: context.customer.profitCenter
    }];

    return {
      differenceType: 'FX_DIFFERENCE',
      originalAmount: receipt.amount,
      differenceAmount: difference,
      journalLines,
      requiresManualReview: false
    };
  }

  /**
   * 過入金処理
   */
  private handleOverpayment(
    receipt: Receipt,
    overpayment: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    // 過入金は前受金計上（要確認）
    const journalLines: JournalLine[] = [{
      lineNo: 1,
      drCr: 'C',
      accountCode: '21300',  // 前受金
      subAccountCode: context.customer.customerId,
      accountName: '前受金',
      amount: overpayment,
      taxCode: 'XX',
      description: `過入金（前受金計上）- ${context.customer.customerName}`,
      segmentPC: context.customer.profitCenter
    }];

    return {
      differenceType: 'OVERPAYMENT',
      originalAmount: receipt.amount,
      differenceAmount: overpayment,
      journalLines,
      requiresManualReview: true,  // 過入金は必ず確認
      reviewReason: `過入金 ${overpayment.toString()}円 - 前受金計上`
    };
  }

  /**
   * 不足入金処理
   */
  private handleUnderpayment(
    receipt: Receipt,
    shortfall: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    const clearedAmount = receipt.amount;
    const shortfallRate = shortfall.abs().div(clearedAmount.plus(shortfall.abs()));

    // 5%以内なら部分消込として自動処理
    const requiresReview = shortfallRate.isGreaterThan(0.05);

    return {
      differenceType: 'UNDERPAYMENT',
      originalAmount: receipt.amount,
      differenceAmount: shortfall,
      journalLines: [], // 部分消込なので追加仕訳なし
      requiresManualReview: requiresReview,
      reviewReason: requiresReview
        ? `不足入金 ${shortfall.abs().toString()}円（${shortfallRate.times(100).toFixed(1)}%）`
        : undefined
    };
  }

  /**
   * 端数処理
   */
  private handleRounding(
    receipt: Receipt,
    difference: Decimal,
    context: ClearingContext
  ): DifferenceResult {
    const isGain = difference.isPositive();

    const journalLines: JournalLine[] = [{
      lineNo: 1,
      drCr: isGain ? 'C' : 'D',
      accountCode: isGain ? '79900' : '79910',  // 雑収入/雑損失
      accountName: isGain ? '雑収入' : '雑損失',
      amount: difference.abs(),
      taxCode: 'XX',
      description: '消込端数差額',
      segmentPC: context.customer.profitCenter
    }];

    return {
      differenceType: 'ROUNDING',
      originalAmount: receipt.amount,
      differenceAmount: difference,
      journalLines,
      requiresManualReview: false
    };
  }

  /**
   * 期待源泉税額計算
   */
  private calculateExpectedWithholding(context: ClearingContext): Decimal {
    // 対象請求書の合計から源泉税計算
    // 100万円以下: 10.21%、100万円超: 20.42%（超過分）
    let totalInvoiceAmount = new Decimal(0);
    for (const candidate of context.candidates || []) {
      if (candidate.documentType === 'INVOICE') {
        totalInvoiceAmount = totalInvoiceAmount.plus(candidate.openAmount);
      }
    }

    const threshold = new Decimal(1000000);
    if (totalInvoiceAmount.isLessThanOrEqualTo(threshold)) {
      return totalInvoiceAmount.times(0.1021).round();
    } else {
      const baseTax = threshold.times(0.1021);
      const excessTax = totalInvoiceAmount.minus(threshold).times(0.2042);
      return baseTax.plus(excessTax).round();
    }
  }
}
```

### 3.3 為替差額計算詳細

```typescript
// ============================================================
// 為替差額計算
// ============================================================

interface FxDifferenceCalculation {
  originalCurrency: CurrencyCode;
  invoiceAmount: Decimal;          // 請求時外貨額
  invoiceRate: Decimal;            // 請求時レート
  invoiceAmountBase: Decimal;      // 請求時円換算額
  receiptAmount: Decimal;          // 入金時外貨額
  receiptRate: Decimal;            // 入金時レート
  receiptAmountBase: Decimal;      // 入金時円換算額
  fxDifference: Decimal;           // 為替差額（円）
  fxDifferenceType: 'GAIN' | 'LOSS';
}

class FxDifferenceCalculator {
  /**
   * 為替差額計算
   *
   * 入金時の円換算額と請求時の円換算額の差額を計算
   * 正の場合は為替差益、負の場合は為替差損
   */
  calculate(
    invoice: ClearingCandidate,
    receipt: Receipt,
    clearAmountFcy: Decimal
  ): FxDifferenceCalculation {
    // 消込対象の外貨額に対する按分計算
    const invoiceRatio = clearAmountFcy.div(invoice.openAmount);

    // 請求時の円換算額（按分）
    const invoiceAmountBase = invoice.amountBase.times(invoiceRatio);

    // 入金時の円換算額
    const receiptAmountBase = clearAmountFcy.times(receipt.exchangeRate);

    // 為替差額
    const fxDifference = receiptAmountBase.minus(invoiceAmountBase);

    return {
      originalCurrency: invoice.currency,
      invoiceAmount: clearAmountFcy,
      invoiceRate: invoice.amountBase.div(invoice.openAmount),
      invoiceAmountBase,
      receiptAmount: clearAmountFcy,
      receiptRate: receipt.exchangeRate,
      receiptAmountBase,
      fxDifference,
      fxDifferenceType: fxDifference.isPositive() ? 'GAIN' : 'LOSS'
    };
  }
}
```

---

## 4. 部分消込

### 4.1 部分消込の処理パターン

| パターン | 説明 | 例 | 処理方法 |
|----------|------|-----|----------|
| 分割入金 | 1件の請求に対して複数回入金 | 100万請求→50万×2回入金 | 入金都度消込 |
| 不足入金 | 請求額未満の入金 | 100万請求→95万入金 | 部分消込＋残高管理 |
| 一部充当 | 複数請求に1回の入金を充当 | 30万+40万請求→50万入金 | 優先順位で充当 |
| 過入金一部返金 | 過入金の一部を返金 | 110万入金→10万返金 | 前受金取崩 |

### 4.2 部分消込ロジック

```typescript
// ============================================================
// 部分消込処理
// ============================================================

interface PartialClearingResult {
  clearing: ClearingRecord;
  journal: Journal;
  invoiceRemaining: Decimal;      // 請求書残高
  receiptRemaining: Decimal;      // 入金残高
  clearingHistory: ClearingHistory[];
}

interface ClearingHistory {
  clearingId: string;
  clearDate: Date;
  clearAmount: Decimal;
  cumulativeCleared: Decimal;
  remaining: Decimal;
  clearedBy: string;
}

class PartialClearingService {
  private clearingRepository: ClearingRepository;
  private invoiceRepository: InvoiceRepository;

  /**
   * 部分消込実行
   */
  async partialClear(
    receipt: Receipt,
    invoice: ClearingCandidate,
    clearAmount: Decimal
  ): Promise<PartialClearingResult> {
    // 1. 事前検証
    this.validatePartialClearing(receipt, invoice, clearAmount);

    // 2. 既存消込履歴取得
    const history = await this.clearingRepository.getClearingHistory(invoice.documentId);

    // 3. 累計消込額計算
    const cumulativeCleared = history.reduce(
      (sum, h) => sum.plus(h.clearAmount),
      new Decimal(0)
    );

    // 4. 消込レコード作成
    const clearing = await this.createPartialClearing(
      receipt,
      invoice,
      clearAmount,
      cumulativeCleared
    );

    // 5. 請求書残高更新
    const newRemaining = invoice.openAmount.minus(clearAmount);
    await this.updateInvoiceBalance(invoice, newRemaining);

    // 6. 仕訳生成
    const journal = await this.generatePartialReceiptJournal(
      receipt,
      invoice,
      clearAmount,
      newRemaining
    );

    // 7. 消込履歴に追加
    history.push({
      clearingId: clearing.clearingId,
      clearDate: clearing.clearDate,
      clearAmount: clearAmount,
      cumulativeCleared: cumulativeCleared.plus(clearAmount),
      remaining: newRemaining,
      clearedBy: clearing.createdBy
    });

    return {
      clearing,
      journal,
      invoiceRemaining: newRemaining,
      receiptRemaining: receipt.amount.minus(clearAmount),
      clearingHistory: history
    };
  }

  /**
   * 部分消込検証
   */
  private validatePartialClearing(
    receipt: Receipt,
    invoice: ClearingCandidate,
    clearAmount: Decimal
  ): void {
    // 消込金額 > 請求残高
    if (clearAmount.isGreaterThan(invoice.openAmount)) {
      throw new ValidationError(
        `消込金額(${clearAmount})が請求残高(${invoice.openAmount})を超過しています`,
        'CLR_E001'
      );
    }

    // 消込金額 > 入金額
    if (clearAmount.isGreaterThan(receipt.amount)) {
      throw new ValidationError(
        `消込金額(${clearAmount})が入金額(${receipt.amount})を超過しています`,
        'CLR_E002'
      );
    }

    // ゼロ以下の消込
    if (clearAmount.isLessThanOrEqualTo(0)) {
      throw new ValidationError(
        '消込金額は正の値である必要があります',
        'CLR_E003'
      );
    }
  }

  /**
   * 請求書残高更新
   */
  private async updateInvoiceBalance(
    invoice: ClearingCandidate,
    newRemaining: Decimal
  ): Promise<void> {
    const newStatus = newRemaining.isZero() ? 'CLEARED' : 'PARTIAL';

    await this.invoiceRepository.updateBalance({
      documentId: invoice.documentId,
      openAmount: newRemaining,
      status: newStatus,
      lastClearedAt: new Date()
    });
  }

  /**
   * 部分入金仕訳生成
   */
  private async generatePartialReceiptJournal(
    receipt: Receipt,
    invoice: ClearingCandidate,
    clearAmount: Decimal,
    remaining: Decimal
  ): Promise<Journal> {
    const lines: JournalLine[] = [
      // 借方: 預金
      {
        lineNo: 1,
        drCr: 'D',
        accountCode: '11100',
        accountName: '普通預金',
        subAccountCode: receipt.accountId,
        amount: clearAmount,
        taxCode: 'XX',
        description: `入金（部分消込）- ${invoice.documentId}`
      },
      // 貸方: 売掛金
      {
        lineNo: 2,
        drCr: 'C',
        accountCode: '12100',
        accountName: '売掛金',
        subAccountCode: invoice.customerId,
        amount: clearAmount,
        taxCode: 'XX',
        description: `売掛金消込（残高: ${remaining}）`
      }
    ];

    return await this.journalGenerator.generateJournal({
      journalType: 'AR_RECEIPT',
      journalDate: receipt.receiptDate,
      lines,
      reference: `${receipt.receiptId}-${invoice.documentId}`,
      description: `部分入金消込 残高${remaining}円`
    });
  }
}
```

### 4.3 消込履歴管理テーブル

| カラム名 | データ型 | 必須 | 説明 |
|----------|----------|------|------|
| clearing_id | VARCHAR(20) | ○ | 消込ID（PK） |
| document_type | VARCHAR(20) | ○ | 文書種別 |
| document_id | VARCHAR(30) | ○ | 消込対象文書ID |
| receipt_payment_id | VARCHAR(30) | ○ | 入金/支払ID |
| clear_amount | DECIMAL(18,2) | ○ | 消込金額 |
| clear_amount_base | DECIMAL(18,2) | ○ | 基軸通貨換算額 |
| clear_date | DATE | ○ | 消込日 |
| clear_type | VARCHAR(10) | ○ | FULL/PARTIAL/REVERSAL |
| match_score | INT | | マッチスコア |
| match_reasons | VARCHAR(500) | | マッチ理由（JSON） |
| status | VARCHAR(10) | ○ | ACTIVE/REVERSED |
| journal_id | VARCHAR(20) | | 関連仕訳ID |
| created_by | VARCHAR(50) | ○ | 作成者 |
| created_at | TIMESTAMP | ○ | 作成日時 |
| reversed_at | TIMESTAMP | | 取消日時 |
| reversed_by | VARCHAR(50) | | 取消者 |
| reversal_reason | VARCHAR(500) | | 取消理由 |

---

## 5. 消込取消（リバーサル）

### 5.1 取消可能条件

| 条件 | 説明 | エラーコード |
|------|------|-------------|
| ステータス | 既に取消済みでないこと | CLR_E010 |
| 会計期間 | 締め済み期間の消込でないこと | CLR_E011 |
| 後続処理 | 後続の消込がないこと（部分消込の場合） | CLR_E012 |
| 入金/支払ステータス | 入金/支払が取消されていないこと | CLR_E013 |
| 承認ステータス | 関連仕訳が最終承認されていないこと | CLR_E014 |

### 5.2 消込取消処理

```typescript
// ============================================================
// 消込取消サービス
// ============================================================

interface ReversalResult {
  originalClearing: ClearingRecord;
  reversalClearing: ClearingRecord;
  reversalJournal: Journal;
  restoredDocument: ClearingCandidate;
}

class ClearingReversalService {
  private clearingRepository: ClearingRepository;
  private journalGenerator: JournalGeneratorService;
  private periodService: AccountingPeriodService;
  private auditLogger: AuditLogger;

  /**
   * 消込取消処理
   */
  async reverseClearing(
    clearingId: string,
    reason: string,
    reversalDate: Date
  ): Promise<ReversalResult> {
    // 1. 消込レコード取得
    const clearing = await this.clearingRepository.findById(clearingId);
    if (!clearing) {
      throw new NotFoundError(`消込ID ${clearingId} が見つかりません`, 'CLR_E009');
    }

    // 2. 取消可能チェック
    await this.validateReversal(clearing, reversalDate);

    // 3. 逆仕訳生成
    const reversalJournal = await this.generateReversalJournal(clearing, reversalDate, reason);

    // 4. 対象文書の残高復元
    const restoredDocument = await this.restoreDocumentBalance(clearing);

    // 5. 消込レコードの取消フラグ設定
    const reversedClearing = await this.markAsReversed(clearing, reason);

    // 6. 取消消込レコード作成
    const reversalClearing = await this.createReversalClearing(clearing, reversalDate, reason);

    // 7. 監査ログ
    await this.auditLogger.log({
      action: 'CLEARING_REVERSAL',
      documentId: clearingId,
      details: {
        reason,
        reversalDate,
        originalJournalId: clearing.journalId,
        reversalJournalId: reversalJournal.journalId,
        restoredAmount: clearing.clearAmount.toString()
      }
    });

    return {
      originalClearing: reversedClearing,
      reversalClearing,
      reversalJournal,
      restoredDocument
    };
  }

  /**
   * 取消可能検証
   */
  private async validateReversal(
    clearing: ClearingRecord,
    reversalDate: Date
  ): Promise<void> {
    // 既に取消済み
    if (clearing.status === 'REVERSED') {
      throw new ValidationError(
        'この消込は既に取消されています',
        'CLR_E010'
      );
    }

    // 締め済み期間チェック
    const periodClosed = await this.periodService.isPeriodClosed(clearing.clearDate);
    if (periodClosed) {
      throw new ValidationError(
        `消込日 ${clearing.clearDate} は締め済み期間です`,
        'CLR_E011'
      );
    }

    // 後続消込チェック（部分消込の場合）
    if (clearing.clearType === 'PARTIAL') {
      const subsequentClearings = await this.clearingRepository.findSubsequentClearings(
        clearing.documentId,
        clearing.clearDate
      );
      if (subsequentClearings.length > 0) {
        throw new ValidationError(
          '後続の消込があるため取消できません。後続から順に取消してください',
          'CLR_E012'
        );
      }
    }

    // 取消日が元の消込日以降であること
    if (reversalDate < clearing.clearDate) {
      throw new ValidationError(
        '取消日は元の消込日以降である必要があります',
        'CLR_E015'
      );
    }
  }

  /**
   * 逆仕訳生成
   */
  private async generateReversalJournal(
    clearing: ClearingRecord,
    reversalDate: Date,
    reason: string
  ): Promise<Journal> {
    // 元仕訳取得
    const originalJournal = await this.journalRepository.findById(clearing.journalId);
    if (!originalJournal) {
      throw new NotFoundError(`関連仕訳が見つかりません`, 'CLR_E016');
    }

    // 逆仕訳明細生成（借方/貸方を反転）
    const reversalLines: JournalLine[] = originalJournal.lines.map((line, index) => ({
      ...line,
      lineNo: index + 1,
      drCr: line.drCr === 'D' ? 'C' : 'D',  // 借方/貸方反転
      description: `【取消】${line.description}`
    }));

    return await this.journalGenerator.generateJournal({
      journalType: 'REVERSAL',
      journalDate: reversalDate,
      lines: reversalLines,
      reference: `REV-${clearing.clearingId}`,
      description: `消込取消: ${reason}`,
      originalJournalId: originalJournal.journalId,
      sourceSystem: 'CLEARING_REVERSAL'
    });
  }

  /**
   * 対象文書の残高復元
   */
  private async restoreDocumentBalance(
    clearing: ClearingRecord
  ): Promise<ClearingCandidate> {
    const document = await this.getDocument(clearing.documentType, clearing.documentId);

    // 残高を復元
    const newOpenAmount = document.openAmount.plus(clearing.clearAmount);

    // ステータス更新
    const newStatus = newOpenAmount.equals(document.totalAmount) ? 'OPEN' : 'PARTIAL';

    await this.updateDocumentBalance(clearing.documentType, clearing.documentId, {
      openAmount: newOpenAmount,
      status: newStatus
    });

    return {
      ...document,
      openAmount: newOpenAmount,
      status: newStatus
    };
  }

  /**
   * 取消フラグ設定
   */
  private async markAsReversed(
    clearing: ClearingRecord,
    reason: string
  ): Promise<ClearingRecord> {
    return await this.clearingRepository.update(clearing.clearingId, {
      status: 'REVERSED',
      reversalReason: reason,
      reversedAt: new Date(),
      reversedBy: getCurrentUser()
    });
  }
}
```

---

## 6. 振替処理

### 6.1 債権債務の振替パターン

| 振替種別 | 振替元 | 振替先 | 用途 | 承認要否 |
|----------|--------|--------|------|----------|
| 得意先間振替 | 得意先A売掛金 | 得意先B売掛金 | グループ内振替 | 要 |
| 仕入先間振替 | 仕入先A買掛金 | 仕入先B買掛金 | グループ内振替 | 要 |
| 勘定振替（AR） | 売掛金 | 未収入金 | 勘定科目変更 | 要 |
| 勘定振替（AP） | 買掛金 | 未払金 | 勘定科目変更 | 要 |
| 前受振替 | 前受金 | 売掛金 | 前受金の充当 | 不要 |
| 前払振替 | 前払金 | 買掛金 | 前払金の充当 | 不要 |
| 相殺振替 | 売掛金 | 買掛金 | 債権債務相殺 | 要 |
| 貸倒振替 | 売掛金 | 貸倒損失 | 貸倒処理 | 要 |
| 敷金振替 | 預り敷金 | 売掛金（原状回復） | 敷金精算 | 要 |

### 6.2 振替処理ロジック

```typescript
// ============================================================
// 振替処理サービス
// ============================================================

interface TransferRequest {
  transferType: TransferType;
  fromAccount: AccountInfo;
  toAccount: AccountInfo;
  amount: Decimal;
  currency: CurrencyCode;
  transferDate: Date;
  reason: string;
  approvalRequired: boolean;
  attachments?: string[];
}

interface AccountInfo {
  accountCode: string;
  subAccountCode?: string;  // 取引先コード等
  segmentPC?: string;
  segmentCC?: string;
  segmentPRJ?: string;
}

type TransferType =
  | 'CUSTOMER_TRANSFER'    // 得意先間振替
  | 'VENDOR_TRANSFER'      // 仕入先間振替
  | 'ACCOUNT_TRANSFER'     // 勘定振替
  | 'ADVANCE_RECEIPT_APPLY' // 前受金充当
  | 'ADVANCE_PAYMENT_APPLY' // 前払金充当
  | 'OFFSET'               // 相殺
  | 'BAD_DEBT'             // 貸倒
  | 'DEPOSIT_SETTLEMENT';  // 敷金精算

class TransferService {
  private journalGenerator: JournalGeneratorService;
  private approvalService: ApprovalService;
  private auditLogger: AuditLogger;

  /**
   * 振替処理メイン
   */
  async processTransfer(request: TransferRequest): Promise<TransferResult> {
    // 1. 入力検証
    this.validateTransferRequest(request);

    // 2. 振替仕訳生成
    const journal = await this.generateTransferJournal(request);

    // 3. 承認要否判定
    if (request.approvalRequired) {
      // 承認フローへ
      const approval = await this.approvalService.requestApproval({
        documentType: 'TRANSFER',
        documentId: journal.journalId,
        amount: request.amount,
        description: request.reason
      });

      return {
        status: 'PENDING_APPROVAL',
        journal,
        approvalId: approval.approvalId
      };
    }

    // 4. 即時実行
    await this.executeTransfer(journal, request);

    return {
      status: 'COMPLETED',
      journal
    };
  }

  /**
   * 振替仕訳生成
   */
  private async generateTransferJournal(request: TransferRequest): Promise<Journal> {
    const lines: JournalLine[] = [];

    // 借方（振替先）
    lines.push({
      lineNo: 1,
      drCr: 'D',
      accountCode: request.toAccount.accountCode,
      subAccountCode: request.toAccount.subAccountCode,
      amount: request.amount,
      currency: request.currency,
      taxCode: 'XX',
      description: this.getTransferDescription(request, 'TO'),
      segmentPC: request.toAccount.segmentPC,
      segmentCC: request.toAccount.segmentCC,
      segmentPRJ: request.toAccount.segmentPRJ
    });

    // 貸方（振替元）
    lines.push({
      lineNo: 2,
      drCr: 'C',
      accountCode: request.fromAccount.accountCode,
      subAccountCode: request.fromAccount.subAccountCode,
      amount: request.amount,
      currency: request.currency,
      taxCode: 'XX',
      description: this.getTransferDescription(request, 'FROM'),
      segmentPC: request.fromAccount.segmentPC,
      segmentCC: request.fromAccount.segmentCC,
      segmentPRJ: request.fromAccount.segmentPRJ
    });

    // 貸倒の場合は貸倒引当金取崩を追加
    if (request.transferType === 'BAD_DEBT') {
      const allowanceAmount = await this.getBadDebtAllowance(
        request.fromAccount.subAccountCode,
        request.amount
      );

      if (!allowanceAmount.isZero()) {
        lines.push({
          lineNo: 3,
          drCr: 'C',
          accountCode: '12190',  // 貸倒引当金
          amount: allowanceAmount,
          taxCode: 'XX',
          description: '貸倒引当金取崩'
        });

        // 貸倒損失を調整
        lines[0].amount = request.amount.minus(allowanceAmount);
      }
    }

    return await this.journalGenerator.generateJournal({
      journalType: 'TRANSFER',
      journalDate: request.transferDate,
      lines,
      description: request.reason,
      sourceSystem: 'TRANSFER_SERVICE'
    });
  }

  /**
   * 得意先間振替
   */
  async transferBetweenCustomers(
    fromCustomerId: string,
    toCustomerId: string,
    invoiceIds: string[],
    reason: string
  ): Promise<TransferResult> {
    // 対象請求書の合計取得
    const invoices = await this.invoiceRepository.findByIds(invoiceIds);
    const totalAmount = invoices.reduce((sum, inv) => sum.plus(inv.openAmount), new Decimal(0));

    // 振替リクエスト作成
    const request: TransferRequest = {
      transferType: 'CUSTOMER_TRANSFER',
      fromAccount: {
        accountCode: '12100',  // 売掛金
        subAccountCode: fromCustomerId
      },
      toAccount: {
        accountCode: '12100',
        subAccountCode: toCustomerId
      },
      amount: totalAmount,
      currency: 'JPY',
      transferDate: new Date(),
      reason: `得意先振替: ${reason}`,
      approvalRequired: true
    };

    return await this.processTransfer(request);
  }

  /**
   * 前受金充当
   */
  async applyAdvanceReceipt(
    customerId: string,
    advanceReceiptId: string,
    invoiceIds: string[],
    applyAmount: Decimal
  ): Promise<TransferResult> {
    // 前受金残高チェック
    const advanceReceipt = await this.advanceReceiptRepository.findById(advanceReceiptId);
    if (advanceReceipt.balance.isLessThan(applyAmount)) {
      throw new ValidationError('前受金残高が不足しています', 'TRF_E001');
    }

    const request: TransferRequest = {
      transferType: 'ADVANCE_RECEIPT_APPLY',
      fromAccount: {
        accountCode: '21300',  // 前受金
        subAccountCode: customerId
      },
      toAccount: {
        accountCode: '12100',  // 売掛金
        subAccountCode: customerId
      },
      amount: applyAmount,
      currency: 'JPY',
      transferDate: new Date(),
      reason: `前受金充当: 請求書 ${invoiceIds.join(', ')}`,
      approvalRequired: false
    };

    const result = await this.processTransfer(request);

    // 対象請求書の消込処理
    await this.clearInvoicesWithAdvance(invoiceIds, applyAmount, result.journal);

    return result;
  }

  /**
   * 債権債務相殺
   */
  async offsetReceivablePayable(
    customerId: string,
    vendorId: string,
    receivableIds: string[],
    payableIds: string[],
    offsetAmount: Decimal
  ): Promise<TransferResult> {
    const request: TransferRequest = {
      transferType: 'OFFSET',
      fromAccount: {
        accountCode: '12100',  // 売掛金
        subAccountCode: customerId
      },
      toAccount: {
        accountCode: '21100',  // 買掛金
        subAccountCode: vendorId
      },
      amount: offsetAmount,
      currency: 'JPY',
      transferDate: new Date(),
      reason: `債権債務相殺: ${customerId} × ${vendorId}`,
      approvalRequired: true
    };

    return await this.processTransfer(request);
  }
}
```

---

## 7. 銀行照合（CM消込）

### 7.1 銀行照合フロー

```
[銀行照合フロー]

                    ┌─────────────────┐
 EB明細データ ─────→│ 1. データ取込    │←───── 銀行API/EB
                    └────────┬────────┘
                             ▼
                    ┌─────────────────┐
 帳簿データ ───────→│ 2. 照合実行      │
                    └────────┬────────┘
                             ▼
              ┌──────────────┼──────────────┐
              ▼              ▼              ▼
      ┌───────────┐  ┌───────────┐  ┌───────────┐
      │ 完全一致   │  │ 候補一致   │  │ 未照合     │
      │ (自動照合) │  │ (確認要)   │  │ (調査要)   │
      └─────┬─────┘  └─────┬─────┘  └─────┬─────┘
            │              │              │
            ▼              ▼              ▼
      ┌───────────────────────────────────────┐
      │ 3. 照合記録・差異管理                  │
      └────────────────────┬──────────────────┘
                           ▼
      ┌───────────────────────────────────────┐
      │ 4. 照合残高表作成                      │
      └───────────────────────────────────────┘
```

### 7.2 銀行照合ロジック

```typescript
// ============================================================
// 銀行照合サービス
// ============================================================

interface BankStatement {
  statementId: string;
  bankCode: string;
  accountNo: string;
  transactionDate: Date;
  valueDate: Date;
  amount: Decimal;
  balance: Decimal;
  transactionType: 'CREDIT' | 'DEBIT';
  description: string;
  reference?: string;
  counterpartyName?: string;
  counterpartyAccount?: string;
  status: 'UNMATCHED' | 'MATCHED' | 'EXCLUDED';
}

interface BookEntry {
  entryId: string;
  journalId: string;
  journalDate: Date;
  accountCode: string;
  subAccountCode: string;  // 銀行口座コード
  amount: Decimal;
  drCr: 'D' | 'C';
  description: string;
  reference?: string;
  status: 'UNMATCHED' | 'MATCHED' | 'EXCLUDED';
}

interface ReconciliationResult {
  reconciliationId: string;
  bankAccountId: string;
  reconciliationDate: Date;
  matched: MatchedPair[];
  unmatchedBank: BankStatement[];
  unmatchedBook: BookEntry[];
  bookBalance: Decimal;
  bankBalance: Decimal;
  difference: Decimal;
  status: 'COMPLETED' | 'DISCREPANCY' | 'IN_PROGRESS';
}

interface MatchedPair {
  bankStatement: BankStatement;
  bookEntries: BookEntry[];
  matchType: 'EXACT' | 'AMOUNT' | 'MULTIPLE' | 'MANUAL';
  matchScore: number;
}

class BankReconciliationService {
  private matchingConfig: ReconciliationConfig;

  constructor(config: ReconciliationConfig) {
    this.matchingConfig = config;
  }

  /**
   * 銀行照合メイン処理
   */
  async reconcile(
    bankAccountId: string,
    startDate: Date,
    endDate: Date
  ): Promise<ReconciliationResult> {
    // 1. データ取得
    const bankStatements = await this.getBankStatements(bankAccountId, startDate, endDate);
    const bookEntries = await this.getBookEntries(bankAccountId, startDate, endDate);

    // 2. 照合実行
    const matchResult = await this.executeMatching(bankStatements, bookEntries);

    // 3. 残高検証
    const bookBalance = await this.calculateBookBalance(bankAccountId, endDate);
    const bankBalance = this.getClosingBalance(bankStatements);

    // 4. 照合結果作成
    const result: ReconciliationResult = {
      reconciliationId: generateReconciliationId(),
      bankAccountId,
      reconciliationDate: endDate,
      matched: matchResult.matched,
      unmatchedBank: matchResult.unmatchedBank,
      unmatchedBook: matchResult.unmatchedBook,
      bookBalance,
      bankBalance,
      difference: bookBalance.minus(bankBalance),
      status: this.determineStatus(matchResult, bookBalance, bankBalance)
    };

    // 5. 照合記録保存
    await this.saveReconciliationResult(result);

    return result;
  }

  /**
   * マッチング実行
   */
  private async executeMatching(
    bankStatements: BankStatement[],
    bookEntries: BookEntry[]
  ): Promise<{
    matched: MatchedPair[];
    unmatchedBank: BankStatement[];
    unmatchedBook: BookEntry[];
  }> {
    const matched: MatchedPair[] = [];
    let unmatchedBank = [...bankStatements.filter(s => s.status !== 'EXCLUDED')];
    let unmatchedBook = [...bookEntries.filter(e => e.status !== 'EXCLUDED')];

    // Phase 1: 完全一致（金額・日付・参照番号）
    const exactMatches = this.findExactMatches(unmatchedBank, unmatchedBook);
    matched.push(...exactMatches);
    unmatchedBank = this.removeMatched(unmatchedBank, exactMatches.map(m => m.bankStatement));
    unmatchedBook = this.removeMatchedEntries(unmatchedBook, exactMatches);

    // Phase 2: 金額一致（日付±許容範囲）
    const amountMatches = this.findAmountMatches(unmatchedBank, unmatchedBook);
    matched.push(...amountMatches);
    unmatchedBank = this.removeMatched(unmatchedBank, amountMatches.map(m => m.bankStatement));
    unmatchedBook = this.removeMatchedEntries(unmatchedBook, amountMatches);

    // Phase 3: 複数対1照合（合計金額一致）
    const multipleMatches = this.findMultipleMatches(unmatchedBank, unmatchedBook);
    matched.push(...multipleMatches);
    unmatchedBank = this.removeMatched(unmatchedBank, multipleMatches.map(m => m.bankStatement));
    unmatchedBook = this.removeMatchedEntries(unmatchedBook, multipleMatches);

    return { matched, unmatchedBank, unmatchedBook };
  }

  /**
   * 完全一致検索
   */
  private findExactMatches(
    bankStatements: BankStatement[],
    bookEntries: BookEntry[]
  ): MatchedPair[] {
    const matches: MatchedPair[] = [];

    for (const statement of bankStatements) {
      const matchingEntry = bookEntries.find(entry =>
        this.isExactMatch(statement, entry)
      );

      if (matchingEntry) {
        matches.push({
          bankStatement: statement,
          bookEntries: [matchingEntry],
          matchType: 'EXACT',
          matchScore: 100
        });
        statement.status = 'MATCHED';
        matchingEntry.status = 'MATCHED';
      }
    }

    return matches;
  }

  /**
   * 完全一致判定
   */
  private isExactMatch(statement: BankStatement, entry: BookEntry): boolean {
    // 金額一致
    const statementAmount = statement.transactionType === 'CREDIT'
      ? statement.amount
      : statement.amount.negated();
    const entryAmount = entry.drCr === 'D' ? entry.amount : entry.amount.negated();

    if (!statementAmount.equals(entryAmount)) return false;

    // 日付一致
    if (!this.isSameDate(statement.transactionDate, entry.journalDate)) return false;

    // 参照番号一致（あれば）
    if (statement.reference && entry.reference) {
      if (statement.reference !== entry.reference) return false;
    }

    return true;
  }

  /**
   * 金額一致検索（日付許容範囲あり）
   */
  private findAmountMatches(
    bankStatements: BankStatement[],
    bookEntries: BookEntry[]
  ): MatchedPair[] {
    const matches: MatchedPair[] = [];
    const dateTolerance = this.matchingConfig.dateTolerance || 3; // デフォルト3日

    for (const statement of bankStatements) {
      const matchingEntry = bookEntries.find(entry =>
        this.isAmountMatch(statement, entry, dateTolerance)
      );

      if (matchingEntry) {
        const daysDiff = Math.abs(
          (statement.transactionDate.getTime() - matchingEntry.journalDate.getTime())
          / (1000 * 60 * 60 * 24)
        );

        matches.push({
          bankStatement: statement,
          bookEntries: [matchingEntry],
          matchType: 'AMOUNT',
          matchScore: 90 - (daysDiff * 5)  // 日付差によりスコア減点
        });
        statement.status = 'MATCHED';
        matchingEntry.status = 'MATCHED';
      }
    }

    return matches;
  }

  /**
   * 金額一致判定
   */
  private isAmountMatch(
    statement: BankStatement,
    entry: BookEntry,
    dateTolerance: number
  ): boolean {
    // 金額一致
    const statementAmount = statement.transactionType === 'CREDIT'
      ? statement.amount
      : statement.amount.negated();
    const entryAmount = entry.drCr === 'D' ? entry.amount : entry.amount.negated();

    if (!statementAmount.equals(entryAmount)) return false;

    // 日付許容範囲内
    const daysDiff = Math.abs(
      (statement.transactionDate.getTime() - entry.journalDate.getTime())
      / (1000 * 60 * 60 * 24)
    );

    return daysDiff <= dateTolerance;
  }

  /**
   * 複数対1照合（合計金額一致）
   */
  private findMultipleMatches(
    bankStatements: BankStatement[],
    bookEntries: BookEntry[]
  ): MatchedPair[] {
    const matches: MatchedPair[] = [];

    for (const statement of bankStatements) {
      // 同一日付の帳簿エントリを検索
      const sameDay = bookEntries.filter(entry =>
        this.isSameDate(statement.transactionDate, entry.journalDate)
      );

      // 合計金額が一致する組み合わせを検索
      const matchingCombination = this.findSumMatch(statement, sameDay);

      if (matchingCombination && matchingCombination.length > 0) {
        matches.push({
          bankStatement: statement,
          bookEntries: matchingCombination,
          matchType: 'MULTIPLE',
          matchScore: 75
        });
        statement.status = 'MATCHED';
        matchingCombination.forEach(e => e.status = 'MATCHED');
      }
    }

    return matches;
  }

  /**
   * 合計金額一致検索
   */
  private findSumMatch(
    statement: BankStatement,
    candidates: BookEntry[]
  ): BookEntry[] | null {
    const targetAmount = statement.transactionType === 'CREDIT'
      ? statement.amount
      : statement.amount.negated();

    // 組み合わせ探索（最大5件まで）
    for (let size = 2; size <= Math.min(5, candidates.length); size++) {
      const combinations = this.getCombinations(candidates, size);

      for (const combo of combinations) {
        const sum = combo.reduce((total, entry) => {
          const amount = entry.drCr === 'D' ? entry.amount : entry.amount.negated();
          return total.plus(amount);
        }, new Decimal(0));

        if (sum.equals(targetAmount)) {
          return combo;
        }
      }
    }

    return null;
  }

  /**
   * 帳簿残高計算
   */
  private async calculateBookBalance(
    bankAccountId: string,
    asOfDate: Date
  ): Promise<Decimal> {
    const entries = await this.bookEntryRepository.findByAccountAndDate(
      bankAccountId,
      asOfDate
    );

    return entries.reduce((balance, entry) => {
      if (entry.drCr === 'D') {
        return balance.plus(entry.amount);
      } else {
        return balance.minus(entry.amount);
      }
    }, new Decimal(0));
  }

  /**
   * 照合残高表生成
   */
  async generateReconciliationStatement(
    result: ReconciliationResult
  ): Promise<ReconciliationStatement> {
    return {
      asOfDate: result.reconciliationDate,
      bankAccountId: result.bankAccountId,

      // 帳簿残高調整
      bookBalance: result.bookBalance,
      addBackItems: result.unmatchedBook
        .filter(e => e.drCr === 'C')
        .map(e => ({
          description: e.description,
          amount: e.amount,
          category: '未取付小切手等'
        })),
      deductItems: result.unmatchedBook
        .filter(e => e.drCr === 'D')
        .map(e => ({
          description: e.description,
          amount: e.amount,
          category: '未記帳入金等'
        })),
      adjustedBookBalance: this.calculateAdjustedBalance(result, 'BOOK'),

      // 銀行残高調整
      bankBalance: result.bankBalance,
      bankAddItems: result.unmatchedBank
        .filter(s => s.transactionType === 'CREDIT')
        .map(s => ({
          description: s.description,
          amount: s.amount,
          category: '未記帳入金'
        })),
      bankDeductItems: result.unmatchedBank
        .filter(s => s.transactionType === 'DEBIT')
        .map(s => ({
          description: s.description,
          amount: s.amount,
          category: '未取付小切手'
        })),
      adjustedBankBalance: this.calculateAdjustedBalance(result, 'BANK'),

      // 差異
      difference: result.difference,
      isReconciled: result.difference.isZero()
    };
  }
}
```

### 7.3 未照合項目の分類

| 分類 | 帳簿側 | 銀行側 | 対応 |
|------|--------|--------|------|
| 未取付小切手 | 出金記帳済 | 未引落 | 経過監視 |
| 未記帳入金 | 未入金記帳 | 入金済 | 入金処理 |
| 未記帳出金 | 未出金記帳 | 出金済 | 出金処理 |
| 入金遅延 | 入金記帳済 | 未入金 | 経過監視 |
| 銀行手数料 | 未記帳 | 手数料引落 | 費用計上 |
| 利息 | 未記帳 | 利息入金 | 収益計上 |
| 誤差 | - | - | 原因調査 |

---

## 8. 業種別消込処理

### 8.1 不動産業向け消込

```typescript
// ============================================================
// 不動産消込モジュール
// ============================================================

interface PropertyClearingContext {
  propertyCode: string;
  unitCode: string;
  tenantId: string;
  contractId: string;
  targetMonth: string;       // YYYY-MM
  rentType: 'BASE_RENT' | 'COMMON_FEE' | 'PARKING' | 'OTHER';
}

class PropertyClearingModule implements IndustryMatcher {
  /**
   * 不動産向けマッチング評価
   */
  async evaluate(
    receipt: Receipt,
    candidate: ClearingCandidate
  ): Promise<{ score: number; reasons: MatchReason[] }> {
    let score = 0;
    const reasons: MatchReason[] = [];

    // 物件・区画一致チェック
    if (candidate.propertyCode && candidate.unitCode) {
      const propertyMatch = await this.checkPropertyMatch(receipt, candidate);
      if (propertyMatch) {
        score += 25;
        reasons.push('PROPERTY_UNIT_MATCH');
      }
    }

    // 登録口座からの振込チェック
    const accountMatch = await this.checkRegisteredAccount(receipt, candidate);
    if (accountMatch) {
      score += 15;
      reasons.push('ACCOUNT_MATCH');
    }

    // 月額賃料金額一致チェック
    const rentMatch = await this.checkMonthlyRentMatch(receipt, candidate);
    if (rentMatch) {
      score += 10;
    }

    return { score, reasons };
  }

  /**
   * 賃料入金消込
   */
  async clearRentReceipt(
    receipt: Receipt,
    rentBill: RentBill,
    context: PropertyClearingContext
  ): Promise<RentClearingResult> {
    const clearings: ClearingRecord[] = [];
    let remainingAmount = receipt.amount;

    // 1. 基本賃料消込
    if (rentBill.baseRent.openAmount.isGreaterThan(0) && remainingAmount.isGreaterThan(0)) {
      const clearAmount = Decimal.min(remainingAmount, rentBill.baseRent.openAmount);
      clearings.push(await this.createRentClearing(receipt, rentBill, 'BASE_RENT', clearAmount));
      remainingAmount = remainingAmount.minus(clearAmount);
    }

    // 2. 共益費消込
    if (rentBill.commonFee.openAmount.isGreaterThan(0) && remainingAmount.isGreaterThan(0)) {
      const clearAmount = Decimal.min(remainingAmount, rentBill.commonFee.openAmount);
      clearings.push(await this.createRentClearing(receipt, rentBill, 'COMMON_FEE', clearAmount));
      remainingAmount = remainingAmount.minus(clearAmount);
    }

    // 3. 駐車場代消込
    if (rentBill.parking.openAmount.isGreaterThan(0) && remainingAmount.isGreaterThan(0)) {
      const clearAmount = Decimal.min(remainingAmount, rentBill.parking.openAmount);
      clearings.push(await this.createRentClearing(receipt, rentBill, 'PARKING', clearAmount));
      remainingAmount = remainingAmount.minus(clearAmount);
    }

    // 仕訳生成
    const journal = await this.generateRentReceiptJournal(receipt, clearings, context);

    return {
      clearings,
      journal,
      remainingReceipt: remainingAmount,
      rentBillStatus: this.determineRentBillStatus(rentBill, clearings)
    };
  }

  /**
   * 敷金精算処理
   */
  async settleDeposit(
    contractId: string,
    settlementDetails: DepositSettlementDetails
  ): Promise<DepositSettlementResult> {
    // 1. 敷金残高取得
    const deposit = await this.depositRepository.findByContract(contractId);

    // 2. 原状回復費用計算
    const restorationCost = settlementDetails.restorationCost;

    // 3. 相殺処理
    const offsetAmount = Decimal.min(deposit.balance, restorationCost);

    // 4. 返還/追加請求額計算
    const refundAmount = deposit.balance.minus(restorationCost);

    // 5. 仕訳生成
    const journalLines: JournalLine[] = [];

    // 敷金取崩
    journalLines.push({
      lineNo: 1,
      drCr: 'D',
      accountCode: '21600',  // 預り敷金
      subAccountCode: deposit.tenantId,
      amount: deposit.balance,
      taxCode: 'XX',
      description: `敷金精算 ${deposit.propertyCode}-${deposit.unitCode}`
    });

    // 原状回復費用（収益）
    if (restorationCost.isGreaterThan(0)) {
      journalLines.push({
        lineNo: 2,
        drCr: 'C',
        accountCode: '41300',  // 原状回復収入
        amount: Decimal.min(restorationCost, deposit.balance),
        taxCode: 'S10',
        description: '原状回復費用'
      });
    }

    // 返還額または追加請求
    if (refundAmount.isPositive()) {
      // 返還
      journalLines.push({
        lineNo: 3,
        drCr: 'C',
        accountCode: '21700',  // 未払金
        subAccountCode: deposit.tenantId,
        amount: refundAmount,
        taxCode: 'XX',
        description: '敷金返還'
      });
    } else if (refundAmount.isNegative()) {
      // 追加請求
      journalLines.push({
        lineNo: 3,
        drCr: 'D',
        accountCode: '12100',  // 売掛金
        subAccountCode: deposit.tenantId,
        amount: refundAmount.abs(),
        taxCode: 'XX',
        description: '原状回復追加請求'
      });
    }

    const journal = await this.journalGenerator.generateJournal({
      journalType: 'DEPOSIT_SETTLEMENT',
      journalDate: settlementDetails.settlementDate,
      lines: journalLines,
      description: `敷金精算 契約${contractId}`
    });

    return {
      depositBalance: deposit.balance,
      restorationCost,
      offsetAmount,
      refundAmount,
      journal
    };
  }
}
```

### 8.2 有価証券業向け消込

```typescript
// ============================================================
// 有価証券消込モジュール
// ============================================================

class SecuritiesClearingModule implements IndustryMatcher {
  /**
   * 有価証券向けマッチング評価
   */
  async evaluate(
    receipt: Receipt,
    candidate: ClearingCandidate
  ): Promise<{ score: number; reasons: MatchReason[] }> {
    let score = 0;
    const reasons: MatchReason[] = [];

    if (candidate.documentType === 'DIVIDEND') {
      // 配当金マッチング
      const dividendMatch = await this.checkDividendMatch(receipt, candidate);
      if (dividendMatch.isMatch) {
        score += dividendMatch.score;
        reasons.push('SECURITY_DIVIDEND_MATCH');
      }
    } else if (candidate.documentType === 'SETTLEMENT') {
      // 売却決済マッチング
      const settlementMatch = await this.checkSettlementMatch(receipt, candidate);
      if (settlementMatch.isMatch) {
        score += settlementMatch.score;
      }
    }

    return { score, reasons };
  }

  /**
   * 配当金入金消込
   */
  async clearDividendReceipt(
    receipt: Receipt,
    dividendNotice: DividendNotice
  ): Promise<DividendClearingResult> {
    // 1. 配当金額検証
    const grossAmount = dividendNotice.grossAmount;
    const withholdingTax = dividendNotice.withholdingTax;
    const netAmount = grossAmount.minus(withholdingTax);

    // 入金額と手取額の差異チェック
    const difference = receipt.amount.minus(netAmount);
    if (difference.abs().isGreaterThan(10)) {
      throw new ValidationError(
        `配当金額の差異が許容範囲外です: ${difference}円`,
        'SEC_E001'
      );
    }

    // 2. 消込レコード作成
    const clearing = await this.createClearing(receipt, dividendNotice, netAmount);

    // 3. 仕訳生成
    const journalLines: JournalLine[] = [
      // 借方: 預金
      {
        lineNo: 1,
        drCr: 'D',
        accountCode: '11100',
        amount: receipt.amount,
        taxCode: 'XX',
        description: `配当金入金 ${dividendNotice.securityCode} ${dividendNotice.securityName}`
      },
      // 借方: 源泉税（控除額）
      {
        lineNo: 2,
        drCr: 'D',
        accountCode: '13400',  // 未収還付税金または仮払税金
        amount: withholdingTax,
        taxCode: 'XX',
        description: '配当源泉税'
      },
      // 貸方: 未収配当金
      {
        lineNo: 3,
        drCr: 'C',
        accountCode: '13200',  // 未収配当金
        subAccountCode: dividendNotice.securityCode,
        amount: grossAmount,
        taxCode: 'XX',
        description: `配当金消込 権利確定日${dividendNotice.recordDate}`
      }
    ];

    // 端数差額処理
    if (!difference.isZero()) {
      journalLines.push({
        lineNo: 4,
        drCr: difference.isPositive() ? 'C' : 'D',
        accountCode: difference.isPositive() ? '79900' : '79910',
        amount: difference.abs(),
        taxCode: 'XX',
        description: '配当金端数差額'
      });
    }

    const journal = await this.journalGenerator.generateJournal({
      journalType: 'DIVIDEND_RECEIPT',
      journalDate: receipt.receiptDate,
      lines: journalLines,
      description: `配当金入金 ${dividendNotice.securityCode}`
    });

    return {
      clearing,
      journal,
      grossAmount,
      withholdingTax,
      netAmount,
      difference
    };
  }

  /**
   * 有価証券売却決済消込
   */
  async clearSecuritiesSettlement(
    receipt: Receipt,
    tradeOrder: TradeOrder
  ): Promise<SettlementClearingResult> {
    // 決済金額検証
    const expectedAmount = tradeOrder.settlementAmount;
    const difference = receipt.amount.minus(expectedAmount);

    if (difference.abs().isGreaterThan(new Decimal(1000))) {
      throw new ValidationError(
        `決済金額の差異が大きすぎます: ${difference}円`,
        'SEC_E002'
      );
    }

    // 仕訳生成（売却損益計算含む）
    const bookValue = await this.calculateBookValue(tradeOrder);
    const salesAmount = tradeOrder.price.times(tradeOrder.quantity);
    const gain = salesAmount.minus(bookValue).minus(tradeOrder.commission);

    const journalLines: JournalLine[] = [
      // 借方: 預金
      {
        lineNo: 1,
        drCr: 'D',
        accountCode: '11100',
        amount: receipt.amount,
        taxCode: 'XX',
        description: `有価証券売却 ${tradeOrder.securityCode}`
      },
      // 借方: 手数料
      {
        lineNo: 2,
        drCr: 'D',
        accountCode: '76300',  // 支払手数料（有価証券）
        amount: tradeOrder.commission,
        taxCode: 'I10',
        description: '証券売買手数料'
      }
    ];

    // 売却損益
    if (gain.isPositive()) {
      journalLines.push({
        lineNo: 3,
        drCr: 'C',
        accountCode: '79300',  // 有価証券売却益
        amount: gain,
        taxCode: 'XX',
        description: '有価証券売却益'
      });
    } else if (gain.isNegative()) {
      journalLines.push({
        lineNo: 3,
        drCr: 'D',
        accountCode: '79400',  // 有価証券売却損
        amount: gain.abs(),
        taxCode: 'XX',
        description: '有価証券売却損'
      });
    }

    // 貸方: 有価証券
    journalLines.push({
      lineNo: 4,
      drCr: 'C',
      accountCode: '14100',  // 有価証券
      subAccountCode: tradeOrder.securityCode,
      amount: bookValue,
      taxCode: 'XX',
      description: `有価証券売却 ${tradeOrder.quantity}株`
    });

    const journal = await this.journalGenerator.generateJournal({
      journalType: 'SECURITIES_SETTLEMENT',
      journalDate: receipt.receiptDate,
      lines: journalLines,
      description: `有価証券売却決済 ${tradeOrder.securityCode}`
    });

    return {
      tradeOrder,
      bookValue,
      salesAmount,
      commission: tradeOrder.commission,
      gain,
      journal
    };
  }
}
```

---

## 9. エラーコードと処理

### 9.1 消込エラーコード一覧

| コード | 区分 | メッセージ | 対応 |
|--------|------|------------|------|
| CLR_E001 | 検証 | 消込金額が請求残高を超過 | 金額修正 |
| CLR_E002 | 検証 | 消込金額が入金額を超過 | 金額修正 |
| CLR_E003 | 検証 | 消込金額が不正（ゼロ以下） | 金額修正 |
| CLR_E004 | 検証 | 通貨不一致 | 通貨確認 |
| CLR_E005 | 検証 | 会計期間外の消込日 | 日付修正 |
| CLR_E009 | データ | 消込IDが見つからない | ID確認 |
| CLR_E010 | 状態 | 既に取消済み | 状態確認 |
| CLR_E011 | 期間 | 締め済み期間の消込 | 期間開放 |
| CLR_E012 | 順序 | 後続消込があり取消不可 | 順次取消 |
| CLR_E013 | 状態 | 入金/支払が取消済み | 状態確認 |
| CLR_E014 | 承認 | 関連仕訳が最終承認済み | 承認取消 |
| CLR_E015 | 日付 | 取消日が消込日より前 | 日付修正 |
| CLR_E016 | データ | 関連仕訳が見つからない | 仕訳確認 |
| TRF_E001 | 振替 | 前受金残高不足 | 残高確認 |
| SEC_E001 | 有価証券 | 配当金額差異が許容外 | 金額確認 |
| SEC_E002 | 有価証券 | 決済金額差異が大きい | 金額確認 |

### 9.2 エラー処理フロー

```typescript
// ============================================================
// 消込エラー処理
// ============================================================

class ClearingErrorHandler {
  private notificationService: NotificationService;
  private auditLogger: AuditLogger;

  /**
   * エラー処理メイン
   */
  async handleError(
    error: ClearingError,
    context: ClearingContext
  ): Promise<ErrorHandlingResult> {
    // 1. エラー分類
    const errorCategory = this.categorizeError(error);

    // 2. リトライ可否判定
    if (this.isRetryable(error) && context.retryCount < 3) {
      return await this.retryClearing(context);
    }

    // 3. エラー通知
    await this.sendErrorNotification(error, context, errorCategory);

    // 4. 監査ログ記録
    await this.auditLogger.logError('CLEARING_ERROR', context.receiptId, {
      errorCode: error.code,
      errorMessage: error.message,
      context: this.sanitizeContext(context)
    });

    // 5. ステータス更新
    await this.updateReceiptStatus(context.receiptId, 'ERROR', error.code);

    return {
      handled: true,
      errorCode: error.code,
      requiresManualIntervention: errorCategory === 'BUSINESS',
      notificationSent: true
    };
  }

  /**
   * エラー分類
   */
  private categorizeError(error: ClearingError): ErrorCategory {
    if (error.code.startsWith('CLR_E00')) {
      return 'VALIDATION';  // 入力検証エラー
    } else if (error.code.startsWith('CLR_E01')) {
      return 'BUSINESS';    // 業務ルールエラー
    } else {
      return 'SYSTEM';      // システムエラー
    }
  }

  /**
   * リトライ可能判定
   */
  private isRetryable(error: ClearingError): boolean {
    const retryableErrors = [
      'CLR_E020',  // タイムアウト
      'CLR_E021',  // DB接続エラー
      'CLR_E022'   // 外部API呼び出しエラー
    ];
    return retryableErrors.includes(error.code);
  }
}
```

---

## 10. 更新履歴

| 版数 | 更新日 | 更新者 | 更新内容 |
|------|--------|--------|----------|
| 1.0 | 2025/01/08 | システム設計チーム | 初版作成 |

---

## 【レビューチェックリスト】

- [ ] 消込優先ルールが業務要件を満たしているか
- [ ] 差額処理のパターンが網羅されているか
- [ ] 為替差額の計算が正しいか
- [ ] 部分消込の残高管理が正確か
- [ ] 消込取消の条件と処理が適切か
- [ ] 銀行照合のマッチングルールが適切か
- [ ] 不動産業向け消込（賃料・敷金）が適切か
- [ ] 有価証券業向け消込（配当・決済）が適切か
- [ ] インボイス制度対応が考慮されているか
- [ ] 監査証跡が記録されているか
- [ ] J-SOX統制要件を満たしているか
- [ ] 経理部門のレビューを受けているか
