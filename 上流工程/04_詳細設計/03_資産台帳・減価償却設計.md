# 資産台帳・減価償却設計

| 項目 | 内容 |
|------|------|
| 文書番号 | DET-FA-ACC-001 |
| 版数 | 1.0 |
| 作成日 | 2025/01/08 |
| 作成者 | システム設計チーム |
| 承認者 | |
| 承認日 | |

---

## 1. 資産管理概要

### 1.1 資産ライフサイクル

本システムでは、IT/コンサルティング事業およびアセットマネジメント（不動産・有価証券）事業で扱う各種資産のライフサイクル全体を管理する。

```
[資産ライフサイクル]

                        ┌─────────────────────────────────────────────────────────────┐
                        │                   稼働中フェーズ                              │
                        │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐            │
[取得]──→[検収]──→[登録]─→│→│ 月次償却 │→│ 資産移動 │→│ 資本的支出│→│ 減損処理 │──→│──→[除却/売却]
  │        │        │      │  └────────┘  └────────┘  └────────┘  └────────┘            │
  │        │        │      └─────────────────────────────────────────────────────────────┘
  ▼        ▼        ▼                                                                         ▼
発注処理  検収仕訳  台帳登録                                                               除却仕訳
予算消化  AP計上    取得仕訳                                                               売却損益

[有価証券の場合]

[取得]──→[約定]──→[決済]──→[保有]──→[評価]──→[売却/償還]
  │        │        │        │        │          │
  ▼        ▼        ▼        ▼        ▼          ▼
購入指示  約定記録  決済仕訳  配当管理  時価評価    売却仕訳
                   台帳登録  利息計上  評価差額    償還差損益
```

### 1.2 資産区分

| 区分コード | 区分名 | 耐用年数目安 | 償却方法（税法） | 勘定科目 | 対象業種 |
|------------|--------|--------------|------------------|----------|----------|
| FA01 | 建物 | 15-50年 | 定額法 | 11010 建物 | 不動産 |
| FA02 | 建物附属設備 | 8-18年 | 定額法 | 11020 建物附属設備 | 不動産 |
| FA03 | 構築物 | 10-35年 | 定額法 | 11030 構築物 | 不動産 |
| FA04 | 機械装置 | 4-15年 | 定率法 | 11040 機械装置 | 共通 |
| FA05 | 車両運搬具 | 3-6年 | 定率法 | 11050 車両運搬具 | 共通 |
| FA06 | 工具器具備品 | 3-15年 | 定率法 | 11060 工具器具備品 | 共通 |
| FA07 | 土地 | - | 非償却 | 11070 土地 | 不動産 |
| FA08 | 建設仮勘定 | - | 非償却 | 11080 建設仮勘定 | 不動産 |
| FA09 | 借地権 | 契約期間 | 定額法 | 12010 借地権 | 不動産 |
| FA10 | ソフトウェア（自社利用） | 5年 | 定額法 | 12020 ソフトウェア | IT/コンサル |
| FA11 | ソフトウェア（市場販売） | 3年 | 見込販売数量 | 12020 ソフトウェア | IT/コンサル |
| FA12 | のれん | 20年以内 | 定額法 | 12030 のれん | 共通 |
| FA13 | その他無形資産 | 契約期間等 | 定額法 | 12090 その他無形 | 共通 |
| SC01 | 売買目的有価証券 | - | 時価評価 | 13010 有価証券 | 有価証券 |
| SC02 | 満期保有目的債券 | - | 償却原価法 | 13020 投資有価証券 | 有価証券 |
| SC03 | その他有価証券 | - | 時価評価 | 13020 投資有価証券 | 有価証券 |
| SC04 | 子会社・関連会社株式 | - | 原価法 | 13030 関係会社株式 | 有価証券 |

### 1.3 資産管理システム構成

```typescript
// ============================================================
// 資産管理システム アーキテクチャ
// ============================================================

interface AssetManagementSystem {
  // コアモジュール
  coreModules: {
    fixedAssetModule: FixedAssetModule;         // 固定資産管理
    depreciationEngine: DepreciationEngine;     // 減価償却エンジン
    securitiesModule: SecuritiesModule;         // 有価証券管理
    propertyModule: PropertyAssetModule;        // 不動産資産管理
    impairmentModule: ImpairmentModule;         // 減損処理
  };

  // 補助モジュール
  supportModules: {
    assetLedger: AssetLedgerService;           // 資産台帳
    taxDifferenceManager: TaxDifferenceManager; // 税会差異管理
    budgetIntegration: BudgetIntegrationService;// 予算連携
    inventoryService: AssetInventoryService;    // 棚卸管理
  };

  // 外部連携
  integrations: {
    apIntegration: APIntegrationService;       // 買掛金連携
    glIntegration: GLIntegrationService;       // 総勘定元帳連携
    taxReportExport: TaxReportExportService;   // 税務申告用出力
  };
}
```

---

## 2. 資産属性

### 2.1 固定資産マスタ項目

| カテゴリ | 項目名 | データ型 | 必須 | 説明 |
|----------|--------|----------|------|------|
| 基本情報 | asset_id | VARCHAR(20) | ○ | 資産番号（PK） |
| | asset_name | VARCHAR(200) | ○ | 資産名称 |
| | asset_category | VARCHAR(4) | ○ | 資産区分コード |
| | asset_sub_category | VARCHAR(4) | | 資産細目コード |
| | acquisition_date | DATE | ○ | 取得日 |
| | service_start_date | DATE | ○ | 稼働開始日 |
| | acquisition_cost | DECIMAL(18,2) | ○ | 取得原価 |
| | acquisition_cost_base | DECIMAL(18,2) | ○ | 取得原価（基軸通貨） |
| | currency | VARCHAR(3) | ○ | 通貨コード |
| 償却情報（会計） | acc_useful_life_months | INT | ○ | 耐用年数（月数・会計） |
| | acc_depreciation_method | VARCHAR(10) | ○ | 償却方法（会計） |
| | acc_residual_value | DECIMAL(18,2) | ○ | 残存価額（会計） |
| | acc_depreciation_rate | DECIMAL(8,5) | | 償却率（会計） |
| | acc_accum_depreciation | DECIMAL(18,2) | | 償却累計額（会計） |
| | acc_book_value | DECIMAL(18,2) | | 帳簿価額（会計） |
| 償却情報（税務） | tax_useful_life_months | INT | ○ | 耐用年数（月数・税務） |
| | tax_depreciation_method | VARCHAR(10) | ○ | 償却方法（税務） |
| | tax_residual_value | DECIMAL(18,2) | ○ | 残存価額（税務） |
| | tax_depreciation_rate | DECIMAL(8,5) | | 償却率（税務） |
| | tax_accum_depreciation | DECIMAL(18,2) | | 償却累計額（税務） |
| | tax_book_value | DECIMAL(18,2) | | 帳簿価額（税務） |
| | tax_guarantee_amount | DECIMAL(18,2) | | 償却保証額（税務） |
| 管理情報 | location_code | VARCHAR(20) | | 設置場所コード |
| | location_name | VARCHAR(100) | | 設置場所名 |
| | dept_code | VARCHAR(10) | ○ | 管理部門コード |
| | user_id | VARCHAR(20) | | 使用者ID |
| | status | VARCHAR(10) | ○ | ACTIVE/SUSPENDED/DISPOSED |
| 構成要素 | parent_asset_id | VARCHAR(20) | | 親資産番号（複合資産） |
| | component_type | VARCHAR(10) | | MAIN/ATTACHMENT/COMPONENT |
| セグメント | segment_pc | VARCHAR(10) | | プロフィットセンター |
| | segment_cc | VARCHAR(10) | | コストセンター |
| | segment_prj | VARCHAR(20) | | プロジェクトコード |
| | segment_unit | VARCHAR(20) | | 物件ユニットコード |
| 監査情報 | created_at | TIMESTAMP | ○ | 作成日時 |
| | created_by | VARCHAR(50) | ○ | 作成者 |
| | updated_at | TIMESTAMP | ○ | 更新日時 |
| | updated_by | VARCHAR(50) | ○ | 更新者 |

### 2.2 有価証券マスタ項目

| カテゴリ | 項目名 | データ型 | 必須 | 説明 |
|----------|--------|----------|------|------|
| 基本情報 | security_holding_id | VARCHAR(20) | ○ | 保有ID（PK） |
| | security_code | VARCHAR(20) | ○ | 銘柄コード |
| | security_name | VARCHAR(200) | ○ | 銘柄名 |
| | security_type | VARCHAR(10) | ○ | STOCK/BOND/FUND/REIT |
| | holding_purpose | VARCHAR(10) | ○ | TRADE/HTM/AFS/SUBSIDIARY |
| | acquisition_date | DATE | ○ | 取得日 |
| | quantity | DECIMAL(18,4) | ○ | 保有数量 |
| | acquisition_price | DECIMAL(18,6) | ○ | 取得単価 |
| | acquisition_cost | DECIMAL(18,2) | ○ | 取得原価 |
| | currency | VARCHAR(3) | ○ | 通貨コード |
| 評価情報 | fair_value | DECIMAL(18,2) | | 時価 |
| | fair_value_date | DATE | | 時価算定日 |
| | valuation_diff | DECIMAL(18,2) | | 評価差額 |
| | valuation_diff_tax | DECIMAL(18,2) | | 評価差額（税効果後） |
| 債券情報 | face_value | DECIMAL(18,2) | | 額面金額 |
| | coupon_rate | DECIMAL(8,5) | | クーポンレート |
| | maturity_date | DATE | | 満期日 |
| | amortized_cost | DECIMAL(18,2) | | 償却原価 |
| 配当情報 | dividend_frequency | VARCHAR(10) | | 配当頻度 |
| | last_dividend_date | DATE | | 最終配当基準日 |
| セグメント | segment_pf | VARCHAR(20) | | ポートフォリオコード |

---

## 3. 減価償却計算

### 3.1 償却方法と計算ロジック

```typescript
// ============================================================
// 減価償却エンジン インターフェース
// ============================================================

type DepreciationMethod =
  | 'SL'        // Straight Line（定額法）
  | 'DB'        // Declining Balance（定率法）
  | 'DB250'     // 250% Declining Balance（250%定率法）
  | 'DB200'     // 200% Declining Balance（200%定率法）
  | 'SYD'       // Sum of Years Digits（級数法）
  | 'UOP'       // Units of Production（生産高比例法）
  | 'NONE';     // 非償却

interface DepreciationParams {
  assetId: string;
  method: DepreciationMethod;
  acquisitionCost: Decimal;
  residualValue: Decimal;
  usefulLifeMonths: number;
  serviceStartDate: Date;
  calculationDate: Date;
  accumulatedDepreciation: Decimal;
  bookValue: Decimal;
  // 定率法用
  depreciationRate?: Decimal;
  guaranteeAmount?: Decimal;
  revisedRate?: Decimal;
  switchedToSL?: boolean;
  // 生産高比例法用
  totalEstimatedUnits?: Decimal;
  currentPeriodUnits?: Decimal;
}

interface DepreciationResult {
  assetId: string;
  calculationDate: Date;
  method: DepreciationMethod;
  monthlyDepreciation: Decimal;
  annualDepreciation: Decimal;
  newAccumulatedDepreciation: Decimal;
  newBookValue: Decimal;
  isFullyDepreciated: boolean;
  calculationDetails: DepreciationCalculationDetail;
}

interface DepreciationCalculationDetail {
  depreciableBase: Decimal;
  rate: Decimal;
  monthsInPeriod: number;
  proRataFactor: Decimal;
  adjustmentAmount: Decimal;
  adjustmentReason?: string;
}

// ============================================================
// 減価償却エンジン実装
// ============================================================

class DepreciationEngine {
  private taxRateTable: TaxDepreciationRateTable;

  constructor(taxRateTable: TaxDepreciationRateTable) {
    this.taxRateTable = taxRateTable;
  }

  /**
   * 月次償却費計算メイン
   */
  calculateMonthlyDepreciation(params: DepreciationParams): DepreciationResult {
    switch (params.method) {
      case 'SL':
        return this.calculateStraightLine(params);
      case 'DB':
      case 'DB250':
      case 'DB200':
        return this.calculateDecliningBalance(params);
      case 'SYD':
        return this.calculateSumOfYearsDigits(params);
      case 'UOP':
        return this.calculateUnitsOfProduction(params);
      case 'NONE':
        return this.noDepreciation(params);
      default:
        throw new Error(`Unknown depreciation method: ${params.method}`);
    }
  }

  /**
   * 定額法による償却費計算
   *
   * 計算式：
   * 年間償却費 = (取得原価 - 残存価額) / 耐用年数
   * 月間償却費 = 年間償却費 / 12
   */
  private calculateStraightLine(params: DepreciationParams): DepreciationResult {
    const depreciableBase = params.acquisitionCost.minus(params.residualValue);
    const usefulLifeYears = params.usefulLifeMonths / 12;
    const annualDepreciation = depreciableBase.div(usefulLifeYears);
    let monthlyDepreciation = annualDepreciation.div(12).floor();

    // 帳簿価額が残存価額に達したら償却停止
    if (params.bookValue.isLessThanOrEqualTo(params.residualValue)) {
      return this.createResult(params, new Decimal(0), true, {
        depreciableBase,
        rate: new Decimal(1).div(usefulLifeYears),
        monthsInPeriod: 1,
        proRataFactor: new Decimal(1),
        adjustmentAmount: new Decimal(0),
        adjustmentReason: 'Fully depreciated'
      });
    }

    // 最終月調整（残存価額ちょうどになるように）
    const remainingValue = params.bookValue.minus(params.residualValue);
    if (monthlyDepreciation.isGreaterThan(remainingValue)) {
      monthlyDepreciation = remainingValue;
    }

    const newAccumDepreciation = params.accumulatedDepreciation.plus(monthlyDepreciation);
    const newBookValue = params.acquisitionCost.minus(newAccumDepreciation);

    return this.createResult(params, monthlyDepreciation,
      newBookValue.isLessThanOrEqualTo(params.residualValue), {
        depreciableBase,
        rate: new Decimal(1).div(usefulLifeYears),
        monthsInPeriod: 1,
        proRataFactor: new Decimal(1),
        adjustmentAmount: new Decimal(0)
      });
  }

  /**
   * 定率法による償却費計算（250%定率法）
   *
   * 計算式：
   * 償却率 = 1 / 耐用年数 × 250%（または200%）
   * 年間償却費 = 期首帳簿価額 × 償却率
   * ※償却保証額を下回ったら改定償却率で均等償却（定額法に移行）
   */
  private calculateDecliningBalance(params: DepreciationParams): DepreciationResult {
    const usefulLifeYears = params.usefulLifeMonths / 12;

    // 償却率の取得または計算
    let depreciationRate = params.depreciationRate;
    if (!depreciationRate) {
      const multiplier = params.method === 'DB200' ? 2.0 : 2.5;
      depreciationRate = new Decimal(1).div(usefulLifeYears).times(multiplier);
    }

    // 期首帳簿価額（前期末帳簿価額）
    const beginningBookValue = params.bookValue;

    // 通常の定率法償却額
    let annualDepreciation = beginningBookValue.times(depreciationRate).floor();

    // 償却保証額との比較
    const guaranteeAmount = params.guaranteeAmount ||
      params.acquisitionCost.times(
        this.taxRateTable.getGuaranteeRate(usefulLifeYears)
      );

    let switchedToSL = params.switchedToSL || false;
    let adjustmentReason: string | undefined;

    // 償却保証額を下回った場合は改定償却率（定額法）に移行
    if (annualDepreciation.isLessThan(guaranteeAmount) && !switchedToSL) {
      switchedToSL = true;
      const revisedRate = params.revisedRate ||
        this.taxRateTable.getRevisedRate(usefulLifeYears);
      annualDepreciation = beginningBookValue.times(revisedRate).floor();
      adjustmentReason = 'Switched to straight-line (below guarantee amount)';
    }

    let monthlyDepreciation = annualDepreciation.div(12).floor();

    // 帳簿価額が残存価額に達したら償却停止
    if (params.bookValue.isLessThanOrEqualTo(params.residualValue)) {
      return this.createResult(params, new Decimal(0), true, {
        depreciableBase: beginningBookValue,
        rate: depreciationRate,
        monthsInPeriod: 1,
        proRataFactor: new Decimal(1),
        adjustmentAmount: new Decimal(0),
        adjustmentReason: 'Fully depreciated'
      });
    }

    // 最終月調整
    const remainingValue = params.bookValue.minus(params.residualValue);
    if (monthlyDepreciation.isGreaterThan(remainingValue)) {
      monthlyDepreciation = remainingValue;
      adjustmentReason = 'Final month adjustment';
    }

    return this.createResult(params, monthlyDepreciation,
      params.bookValue.minus(monthlyDepreciation).isLessThanOrEqualTo(params.residualValue), {
        depreciableBase: beginningBookValue,
        rate: depreciationRate,
        monthsInPeriod: 1,
        proRataFactor: new Decimal(1),
        adjustmentAmount: new Decimal(0),
        adjustmentReason
      });
  }

  /**
   * 初年度月割計算
   */
  calculateFirstYearDepreciation(
    params: DepreciationParams,
    fiscalYearEnd: { month: number; day: number }
  ): DepreciationResult {
    const startDate = params.serviceStartDate;
    const startMonth = startDate.getMonth() + 1;  // 0-indexed to 1-indexed

    // 期末月までの月数を計算
    let operatingMonths: number;
    if (startMonth <= fiscalYearEnd.month) {
      operatingMonths = fiscalYearEnd.month - startMonth + 1;
    } else {
      operatingMonths = (12 - startMonth + 1) + fiscalYearEnd.month;
    }

    // 年間償却費を計算
    const annualResult = this.calculateMonthlyDepreciation(params);
    const annualDepreciation = annualResult.annualDepreciation;

    // 月割計算
    const firstYearDepreciation = annualDepreciation
      .times(operatingMonths)
      .div(12)
      .floor();

    return {
      ...annualResult,
      monthlyDepreciation: firstYearDepreciation,
      calculationDetails: {
        ...annualResult.calculationDetails,
        monthsInPeriod: operatingMonths,
        proRataFactor: new Decimal(operatingMonths).div(12)
      }
    };
  }

  /**
   * 結果オブジェクト作成
   */
  private createResult(
    params: DepreciationParams,
    monthlyDepreciation: Decimal,
    isFullyDepreciated: boolean,
    details: DepreciationCalculationDetail
  ): DepreciationResult {
    const newAccumDepreciation = params.accumulatedDepreciation.plus(monthlyDepreciation);
    const newBookValue = params.acquisitionCost.minus(newAccumDepreciation);

    return {
      assetId: params.assetId,
      calculationDate: params.calculationDate,
      method: params.method,
      monthlyDepreciation,
      annualDepreciation: monthlyDepreciation.times(12),
      newAccumulatedDepreciation: newAccumDepreciation,
      newBookValue,
      isFullyDepreciated,
      calculationDetails: details
    };
  }
}
```

### 3.2 償却保証額・改定償却率テーブル

```typescript
// ============================================================
// 税法償却率テーブル（令和4年4月1日以降取得資産）
// ============================================================

class TaxDepreciationRateTable {
  private static readonly RATE_TABLE: Map<number, {
    decliningRate: number;    // 定率法償却率
    guaranteeRate: number;    // 償却保証率
    revisedRate: number;      // 改定償却率
  }> = new Map([
    [2, { decliningRate: 1.000, guaranteeRate: 0.00000, revisedRate: 0.000 }],
    [3, { decliningRate: 0.833, guaranteeRate: 0.02789, revisedRate: 1.000 }],
    [4, { decliningRate: 0.625, guaranteeRate: 0.05274, revisedRate: 1.000 }],
    [5, { decliningRate: 0.500, guaranteeRate: 0.06249, revisedRate: 0.500 }],
    [6, { decliningRate: 0.417, guaranteeRate: 0.05776, revisedRate: 0.500 }],
    [7, { decliningRate: 0.357, guaranteeRate: 0.05496, revisedRate: 0.500 }],
    [8, { decliningRate: 0.313, guaranteeRate: 0.05111, revisedRate: 0.334 }],
    [9, { decliningRate: 0.278, guaranteeRate: 0.04731, revisedRate: 0.334 }],
    [10, { decliningRate: 0.250, guaranteeRate: 0.04448, revisedRate: 0.334 }],
    [11, { decliningRate: 0.227, guaranteeRate: 0.04123, revisedRate: 0.250 }],
    [12, { decliningRate: 0.208, guaranteeRate: 0.03870, revisedRate: 0.250 }],
    [13, { decliningRate: 0.192, guaranteeRate: 0.03633, revisedRate: 0.250 }],
    [14, { decliningRate: 0.179, guaranteeRate: 0.03389, revisedRate: 0.200 }],
    [15, { decliningRate: 0.167, guaranteeRate: 0.03217, revisedRate: 0.200 }],
    [16, { decliningRate: 0.156, guaranteeRate: 0.03063, revisedRate: 0.167 }],
    [17, { decliningRate: 0.147, guaranteeRate: 0.02905, revisedRate: 0.167 }],
    [18, { decliningRate: 0.139, guaranteeRate: 0.02757, revisedRate: 0.167 }],
    [19, { decliningRate: 0.132, guaranteeRate: 0.02616, revisedRate: 0.143 }],
    [20, { decliningRate: 0.125, guaranteeRate: 0.02517, revisedRate: 0.143 }],
    [25, { decliningRate: 0.100, guaranteeRate: 0.02066, revisedRate: 0.112 }],
    [30, { decliningRate: 0.083, guaranteeRate: 0.01766, revisedRate: 0.091 }],
    [35, { decliningRate: 0.071, guaranteeRate: 0.01532, revisedRate: 0.077 }],
    [40, { decliningRate: 0.063, guaranteeRate: 0.01351, revisedRate: 0.067 }],
    [45, { decliningRate: 0.056, guaranteeRate: 0.01208, revisedRate: 0.059 }],
    [50, { decliningRate: 0.050, guaranteeRate: 0.01095, revisedRate: 0.053 }],
  ]);

  /**
   * 定率法償却率取得
   */
  getDecliningRate(usefulLifeYears: number): Decimal {
    const entry = TaxDepreciationRateTable.RATE_TABLE.get(usefulLifeYears);
    if (entry) {
      return new Decimal(entry.decliningRate);
    }
    // テーブルにない場合は計算（250%定率法）
    return new Decimal(1).div(usefulLifeYears).times(2.5).round(3);
  }

  /**
   * 償却保証率取得
   */
  getGuaranteeRate(usefulLifeYears: number): Decimal {
    const entry = TaxDepreciationRateTable.RATE_TABLE.get(usefulLifeYears);
    if (entry) {
      return new Decimal(entry.guaranteeRate);
    }
    // 近似値を使用
    return new Decimal(0.01);
  }

  /**
   * 改定償却率取得
   */
  getRevisedRate(usefulLifeYears: number): Decimal {
    const entry = TaxDepreciationRateTable.RATE_TABLE.get(usefulLifeYears);
    if (entry) {
      return new Decimal(entry.revisedRate);
    }
    // 残存期間での定額法償却率を使用
    return new Decimal(1).div(usefulLifeYears);
  }
}
```

### 3.3 IFRS対応償却（コンポーネントアプローチ）

```typescript
// ============================================================
// IFRS コンポーネントアプローチ
// ============================================================

interface AssetComponent {
  componentId: string;
  componentName: string;
  parentAssetId: string;
  componentType: 'MAJOR' | 'MINOR' | 'OVERHAUL';
  acquisitionCost: Decimal;
  usefulLifeMonths: number;
  residualValue: Decimal;
  depreciationMethod: DepreciationMethod;
}

class IFRSDepreciationService {
  private depreciationEngine: DepreciationEngine;

  /**
   * コンポーネント別償却計算
   * IFRSでは重要な構成要素ごとに耐用年数を設定し個別に償却
   */
  calculateComponentDepreciation(
    asset: FixedAsset,
    components: AssetComponent[],
    calculationDate: Date
  ): ComponentDepreciationResult {
    const componentResults: DepreciationResult[] = [];
    let totalMonthlyDepreciation = new Decimal(0);

    for (const component of components) {
      const params: DepreciationParams = {
        assetId: component.componentId,
        method: component.depreciationMethod,
        acquisitionCost: component.acquisitionCost,
        residualValue: component.residualValue,
        usefulLifeMonths: component.usefulLifeMonths,
        serviceStartDate: asset.serviceStartDate,
        calculationDate,
        accumulatedDepreciation: component.accumulatedDepreciation,
        bookValue: component.bookValue
      };

      const result = this.depreciationEngine.calculateMonthlyDepreciation(params);
      componentResults.push(result);
      totalMonthlyDepreciation = totalMonthlyDepreciation.plus(result.monthlyDepreciation);
    }

    return {
      assetId: asset.assetId,
      calculationDate,
      componentResults,
      totalMonthlyDepreciation,
      totalNewBookValue: componentResults.reduce(
        (sum, r) => sum.plus(r.newBookValue),
        new Decimal(0)
      )
    };
  }

  /**
   * 大規模修繕（オーバーホール）の資産化
   */
  capitalizeOverhaul(
    asset: FixedAsset,
    overhaulCost: Decimal,
    overhaulDate: Date,
    estimatedNextOverhaulMonths: number
  ): AssetComponent {
    // 既存のオーバーホールコンポーネントがあれば除却
    const existingOverhaul = asset.components?.find(c => c.componentType === 'OVERHAUL');
    if (existingOverhaul) {
      this.disposeComponent(existingOverhaul, overhaulDate);
    }

    // 新規オーバーホールコンポーネント作成
    return {
      componentId: generateComponentId(),
      componentName: `${asset.assetName} - Overhaul ${overhaulDate.toISOString().slice(0, 10)}`,
      parentAssetId: asset.assetId,
      componentType: 'OVERHAUL',
      acquisitionCost: overhaulCost,
      usefulLifeMonths: estimatedNextOverhaulMonths,
      residualValue: new Decimal(0),
      depreciationMethod: 'SL'
    };
  }
}
```

---

## 4. 会計と税務の差異管理

### 4.1 差異発生パターン

| 項目 | 会計処理 | 税務処理 | 差異種類 | 税効果 |
|------|----------|----------|----------|--------|
| 耐用年数 | 経済的耐用年数（見積） | 法定耐用年数 | 一時差異 | あり |
| 残存価額 | ゼロまたは見込額 | 備忘価額1円 | 一時差異 | あり |
| 償却方法 | 経済実態に応じた方法 | 税法規定の方法 | 一時差異 | あり |
| 減損損失 | 発生時に認識 | 損金不算入 | 一時差異 | あり |
| 資産除去債務 | 負債計上+資産計上 | 実際支出時損金 | 一時差異 | あり |
| 少額資産 | 費用処理可 | 取得価額基準 | 永久差異 | なし |
| 圧縮記帳 | 圧縮不可 | 圧縮可 | 一時差異 | あり |

### 4.2 税会差異管理ロジック

```typescript
// ============================================================
// 税会差異管理サービス
// ============================================================

interface TaxAccountingDifference {
  assetId: string;
  fiscalYear: string;
  differenceType: 'TEMPORARY' | 'PERMANENT';
  category: DifferenceCategory;
  accountingAmount: Decimal;      // 会計上の金額
  taxAmount: Decimal;             // 税務上の金額
  differenceAmount: Decimal;      // 差異額
  deferredTaxAsset: Decimal;      // 繰延税金資産
  deferredTaxLiability: Decimal;  // 繰延税金負債
}

type DifferenceCategory =
  | 'USEFUL_LIFE'           // 耐用年数差異
  | 'RESIDUAL_VALUE'        // 残存価額差異
  | 'DEPRECIATION_METHOD'   // 償却方法差異
  | 'IMPAIRMENT'            // 減損差異
  | 'ARO'                   // 資産除去債務差異
  | 'COMPRESSION';          // 圧縮記帳差異

class TaxDifferenceManager {
  private effectiveTaxRate: Decimal = new Decimal(0.3);  // 実効税率30%

  /**
   * 月次償却差異計算
   */
  calculateMonthlyDifference(
    asset: FixedAsset,
    accountingDepreciation: DepreciationResult,
    taxDepreciation: DepreciationResult
  ): TaxAccountingDifference {
    const differenceAmount = accountingDepreciation.monthlyDepreciation
      .minus(taxDepreciation.monthlyDepreciation);

    // 会計 > 税務 の場合: 繰延税金資産（将来の税負担軽減）
    // 会計 < 税務 の場合: 繰延税金負債（将来の税負担増加）
    let deferredTaxAsset = new Decimal(0);
    let deferredTaxLiability = new Decimal(0);

    if (differenceAmount.isPositive()) {
      deferredTaxAsset = differenceAmount.times(this.effectiveTaxRate);
    } else if (differenceAmount.isNegative()) {
      deferredTaxLiability = differenceAmount.abs().times(this.effectiveTaxRate);
    }

    return {
      assetId: asset.assetId,
      fiscalYear: this.getFiscalYear(accountingDepreciation.calculationDate),
      differenceType: 'TEMPORARY',
      category: this.identifyDifferenceCategory(asset),
      accountingAmount: accountingDepreciation.monthlyDepreciation,
      taxAmount: taxDepreciation.monthlyDepreciation,
      differenceAmount,
      deferredTaxAsset,
      deferredTaxLiability
    };
  }

  /**
   * 減損損失の税効果計算
   */
  calculateImpairmentTaxEffect(
    asset: FixedAsset,
    impairmentLoss: Decimal
  ): TaxAccountingDifference {
    // 減損損失は税務上損金不算入（将来売却/除却時に損金算入）
    const deferredTaxAsset = impairmentLoss.times(this.effectiveTaxRate);

    return {
      assetId: asset.assetId,
      fiscalYear: this.getCurrentFiscalYear(),
      differenceType: 'TEMPORARY',
      category: 'IMPAIRMENT',
      accountingAmount: impairmentLoss,
      taxAmount: new Decimal(0),
      differenceAmount: impairmentLoss,
      deferredTaxAsset,
      deferredTaxLiability: new Decimal(0)
    };
  }

  /**
   * 申告調整明細作成
   */
  generateTaxAdjustmentSchedule(
    differences: TaxAccountingDifference[],
    fiscalYear: string
  ): TaxAdjustmentSchedule {
    const additions: TaxAdjustmentItem[] = [];
    const deductions: TaxAdjustmentItem[] = [];

    for (const diff of differences) {
      if (diff.differenceAmount.isPositive()) {
        // 会計 > 税務 → 加算項目
        additions.push({
          category: diff.category,
          description: this.getAdjustmentDescription(diff),
          amount: diff.differenceAmount,
          assetId: diff.assetId
        });
      } else if (diff.differenceAmount.isNegative()) {
        // 会計 < 税務 → 減算項目
        deductions.push({
          category: diff.category,
          description: this.getAdjustmentDescription(diff),
          amount: diff.differenceAmount.abs(),
          assetId: diff.assetId
        });
      }
    }

    return {
      fiscalYear,
      additions,
      deductions,
      totalAdditions: additions.reduce((sum, a) => sum.plus(a.amount), new Decimal(0)),
      totalDeductions: deductions.reduce((sum, d) => sum.plus(d.amount), new Decimal(0))
    };
  }
}
```

### 4.3 少額資産の処理

```typescript
// ============================================================
// 少額資産処理
// ============================================================

interface SmallAssetClassification {
  acquisitionCost: Decimal;
  classification: SmallAssetType;
  accountingTreatment: 'EXPENSE' | 'DEPRECIATE' | 'BULK_DEPRECIATE';
  taxTreatment: 'EXPENSE' | 'DEPRECIATE' | 'BULK_DEPRECIATE' | 'SME_SPECIAL';
}

type SmallAssetType =
  | 'IMMEDIATE_EXPENSE'    // 10万円未満：即時費用
  | 'BULK_3YEAR'           // 10万円以上20万円未満：一括償却（3年）
  | 'SME_SPECIAL'          // 20万円以上30万円未満：中小企業特例
  | 'NORMAL';              // 30万円以上：通常償却

class SmallAssetProcessor {
  private readonly SME_SPECIAL_LIMIT = new Decimal(300000);
  private readonly BULK_LOWER_LIMIT = new Decimal(100000);
  private readonly BULK_UPPER_LIMIT = new Decimal(200000);
  private readonly IMMEDIATE_EXPENSE_LIMIT = new Decimal(100000);

  /**
   * 少額資産の分類判定
   */
  classifySmallAsset(
    acquisitionCost: Decimal,
    companyType: 'SME' | 'LARGE'
  ): SmallAssetClassification {
    // 10万円未満
    if (acquisitionCost.isLessThan(this.IMMEDIATE_EXPENSE_LIMIT)) {
      return {
        acquisitionCost,
        classification: 'IMMEDIATE_EXPENSE',
        accountingTreatment: 'EXPENSE',
        taxTreatment: 'EXPENSE'
      };
    }

    // 10万円以上20万円未満
    if (acquisitionCost.isLessThan(this.BULK_UPPER_LIMIT)) {
      return {
        acquisitionCost,
        classification: 'BULK_3YEAR',
        accountingTreatment: 'BULK_DEPRECIATE',
        taxTreatment: 'BULK_DEPRECIATE'
      };
    }

    // 20万円以上30万円未満（中小企業の場合は特例適用可）
    if (acquisitionCost.isLessThan(this.SME_SPECIAL_LIMIT) && companyType === 'SME') {
      return {
        acquisitionCost,
        classification: 'SME_SPECIAL',
        accountingTreatment: 'DEPRECIATE',  // 会計上は通常償却
        taxTreatment: 'SME_SPECIAL'         // 税務上は即時償却可
      };
    }

    // 30万円以上
    return {
      acquisitionCost,
      classification: 'NORMAL',
      accountingTreatment: 'DEPRECIATE',
      taxTreatment: 'DEPRECIATE'
    };
  }

  /**
   * 一括償却資産の償却計算（3年均等）
   */
  calculateBulkDepreciation(
    assets: FixedAsset[],
    fiscalYear: string
  ): BulkDepreciationResult {
    // 当期取得の一括償却資産の合計
    const currentYearTotal = assets
      .filter(a => this.getFiscalYear(a.acquisitionDate) === fiscalYear)
      .reduce((sum, a) => sum.plus(a.acquisitionCost), new Decimal(0));

    // 前期・前々期取得分の残高
    const priorYearBalance = this.getPriorYearBulkBalance(fiscalYear);

    // 当期償却額 = (当期取得分 + 前期残高) / 3
    const depreciationBase = currentYearTotal.plus(priorYearBalance);
    const annualDepreciation = depreciationBase.div(3).floor();
    const monthlyDepreciation = annualDepreciation.div(12).floor();

    return {
      fiscalYear,
      currentYearAcquisitions: currentYearTotal,
      priorYearBalance,
      depreciationBase,
      annualDepreciation,
      monthlyDepreciation,
      yearEndBalance: depreciationBase.minus(annualDepreciation)
    };
  }
}
```

---

## 5. 資産の移動・資本的支出

### 5.1 資産移動処理

```typescript
// ============================================================
// 資産移動サービス
// ============================================================

interface AssetTransfer {
  transferId: string;
  assetId: string;
  transferDate: Date;
  transferType: 'LOCATION' | 'DEPARTMENT' | 'SEGMENT' | 'COMPANY';
  fromLocation?: string;
  toLocation?: string;
  fromDept?: string;
  toDept?: string;
  fromSegment?: SegmentInfo;
  toSegment?: SegmentInfo;
  reason: string;
  approvalStatus: 'PENDING' | 'APPROVED' | 'REJECTED';
}

interface SegmentInfo {
  pc: string;   // プロフィットセンター
  cc: string;   // コストセンター
  prj?: string; // プロジェクト
}

class AssetTransferService {
  private assetRepository: AssetRepository;
  private journalGenerator: JournalGeneratorService;
  private auditLogger: AuditLogger;

  /**
   * 資産移動処理
   */
  async transferAsset(transfer: AssetTransfer): Promise<TransferResult> {
    const asset = await this.assetRepository.findById(transfer.assetId);
    if (!asset) {
      throw new NotFoundError(`Asset ${transfer.assetId} not found`);
    }

    // 1. 移動履歴記録
    const history = await this.recordTransferHistory(asset, transfer);

    // 2. セグメント移動の場合は振替仕訳生成
    let journal: Journal | null = null;
    if (transfer.transferType === 'DEPARTMENT' || transfer.transferType === 'SEGMENT') {
      journal = await this.generateTransferJournal(asset, transfer);
    }

    // 3. 会社間移動の場合は除却+取得処理
    if (transfer.transferType === 'COMPANY') {
      return await this.processIntercompanyTransfer(asset, transfer);
    }

    // 4. 資産情報更新
    await this.updateAssetInfo(asset, transfer);

    // 5. 監査ログ
    await this.auditLogger.log({
      action: 'ASSET_TRANSFER',
      documentId: transfer.transferId,
      details: {
        assetId: asset.assetId,
        transferType: transfer.transferType,
        from: transfer.fromDept || transfer.fromLocation,
        to: transfer.toDept || transfer.toLocation
      }
    });

    return {
      transferId: transfer.transferId,
      history,
      journal,
      updatedAsset: asset
    };
  }

  /**
   * 部門間振替仕訳生成
   */
  private async generateTransferJournal(
    asset: FixedAsset,
    transfer: AssetTransfer
  ): Promise<Journal> {
    const lines: JournalLine[] = [];

    // 取得原価の振替
    lines.push({
      lineNo: 1,
      drCr: 'D',
      accountCode: this.getAssetAccountCode(asset),
      amount: asset.acquisitionCost,
      taxCode: 'XX',
      description: `資産移動（受入）${asset.assetName}`,
      segmentPC: transfer.toSegment?.pc,
      segmentCC: transfer.toSegment?.cc
    });

    lines.push({
      lineNo: 2,
      drCr: 'C',
      accountCode: this.getAssetAccountCode(asset),
      amount: asset.acquisitionCost,
      taxCode: 'XX',
      description: `資産移動（払出）${asset.assetName}`,
      segmentPC: transfer.fromSegment?.pc,
      segmentCC: transfer.fromSegment?.cc
    });

    // 減価償却累計額の振替
    if (asset.accAccumDepreciation.isGreaterThan(0)) {
      lines.push({
        lineNo: 3,
        drCr: 'D',
        accountCode: this.getAccumDepreciationAccountCode(asset),
        amount: asset.accAccumDepreciation,
        taxCode: 'XX',
        description: `減価償却累計額移動（払出）`,
        segmentPC: transfer.fromSegment?.pc,
        segmentCC: transfer.fromSegment?.cc
      });

      lines.push({
        lineNo: 4,
        drCr: 'C',
        accountCode: this.getAccumDepreciationAccountCode(asset),
        amount: asset.accAccumDepreciation,
        taxCode: 'XX',
        description: `減価償却累計額移動（受入）`,
        segmentPC: transfer.toSegment?.pc,
        segmentCC: transfer.toSegment?.cc
      });
    }

    return await this.journalGenerator.generateJournal({
      journalType: 'ASSET_TRANSFER',
      journalDate: transfer.transferDate,
      lines,
      description: `資産移動 ${asset.assetId} ${transfer.reason}`,
      reference: transfer.transferId
    });
  }
}
```

### 5.2 資本的支出処理

```typescript
// ============================================================
// 資本的支出サービス
// ============================================================

interface CapitalExpenditure {
  expenditureId: string;
  assetId: string;
  expenditureDate: Date;
  expenditureType: 'IMPROVEMENT' | 'ADDITION' | 'REPLACEMENT';
  description: string;
  amount: Decimal;
  vendorId: string;
  invoiceId?: string;
  treatmentType: 'CAPITALIZE' | 'EXPENSE';  // 資本的支出 or 修繕費
  newUsefulLifeMonths?: number;             // 耐用年数の延長（改良の場合）
}

class CapitalExpenditureService {
  /**
   * 資本的支出判定
   * 税法基準: 20万円未満→修繕費、20万円以上→個別判定
   */
  determineTreatment(expenditure: CapitalExpenditure): 'CAPITALIZE' | 'EXPENSE' {
    // 20万円未満は修繕費として処理可能
    if (expenditure.amount.isLessThan(200000)) {
      return 'EXPENSE';
    }

    // 資産価値の増加または耐用年数の延長がある場合は資本的支出
    if (expenditure.expenditureType === 'IMPROVEMENT' ||
        expenditure.newUsefulLifeMonths) {
      return 'CAPITALIZE';
    }

    // 原状回復は修繕費
    if (expenditure.expenditureType === 'REPLACEMENT') {
      return 'EXPENSE';
    }

    // デフォルトは資本的支出
    return 'CAPITALIZE';
  }

  /**
   * 資本的支出の処理
   */
  async processCapitalExpenditure(
    expenditure: CapitalExpenditure
  ): Promise<CapitalExpenditureResult> {
    const asset = await this.assetRepository.findById(expenditure.assetId);
    if (!asset) {
      throw new NotFoundError(`Asset ${expenditure.assetId} not found`);
    }

    const treatment = expenditure.treatmentType || this.determineTreatment(expenditure);

    if (treatment === 'CAPITALIZE') {
      return await this.capitalizeExpenditure(asset, expenditure);
    } else {
      return await this.expenseExpenditure(asset, expenditure);
    }
  }

  /**
   * 資本的支出として資産計上
   */
  private async capitalizeExpenditure(
    asset: FixedAsset,
    expenditure: CapitalExpenditure
  ): Promise<CapitalExpenditureResult> {
    // 取得原価に加算
    const newAcquisitionCost = asset.acquisitionCost.plus(expenditure.amount);

    // 耐用年数の見直し（延長がある場合）
    let newUsefulLife = asset.accUsefulLifeMonths;
    if (expenditure.newUsefulLifeMonths) {
      newUsefulLife = expenditure.newUsefulLifeMonths;
    }

    // 帳簿価額に加算
    const newBookValue = asset.accBookValue.plus(expenditure.amount);

    // 資産情報更新
    await this.assetRepository.update(asset.assetId, {
      acquisitionCost: newAcquisitionCost,
      accUsefulLifeMonths: newUsefulLife,
      accBookValue: newBookValue
    });

    // 仕訳生成
    const journal = await this.generateCapitalExpenditureJournal(
      asset,
      expenditure,
      'CAPITALIZE'
    );

    return {
      expenditureId: expenditure.expenditureId,
      treatment: 'CAPITALIZE',
      journal,
      updatedAsset: {
        ...asset,
        acquisitionCost: newAcquisitionCost,
        accUsefulLifeMonths: newUsefulLife,
        accBookValue: newBookValue
      }
    };
  }

  /**
   * 資本的支出の仕訳生成
   */
  private async generateCapitalExpenditureJournal(
    asset: FixedAsset,
    expenditure: CapitalExpenditure,
    treatment: 'CAPITALIZE' | 'EXPENSE'
  ): Promise<Journal> {
    const lines: JournalLine[] = [];

    if (treatment === 'CAPITALIZE') {
      // 借方: 固定資産
      lines.push({
        lineNo: 1,
        drCr: 'D',
        accountCode: this.getAssetAccountCode(asset),
        amount: expenditure.amount,
        taxCode: this.getTaxCode(expenditure),
        description: `資本的支出 ${expenditure.description}`,
        segmentPC: asset.segmentPc,
        segmentCC: asset.segmentCc
      });

      // 貸方: 買掛金/未払金
      lines.push({
        lineNo: 2,
        drCr: 'C',
        accountCode: '21100',  // 買掛金
        subAccountCode: expenditure.vendorId,
        amount: expenditure.amount,
        taxCode: 'XX',
        description: `資本的支出 ${asset.assetId}`
      });
    } else {
      // 借方: 修繕費
      lines.push({
        lineNo: 1,
        drCr: 'D',
        accountCode: '74100',  // 修繕費
        amount: expenditure.amount,
        taxCode: this.getTaxCode(expenditure),
        description: `修繕費 ${expenditure.description}`,
        segmentPC: asset.segmentPc,
        segmentCC: asset.segmentCc
      });

      // 貸方: 買掛金/未払金
      lines.push({
        lineNo: 2,
        drCr: 'C',
        accountCode: '21100',
        subAccountCode: expenditure.vendorId,
        amount: expenditure.amount,
        taxCode: 'XX',
        description: `修繕費 ${asset.assetId}`
      });
    }

    return await this.journalGenerator.generateJournal({
      journalType: treatment === 'CAPITALIZE' ? 'ASSET_ACQUISITION' : 'EXPENSE',
      journalDate: expenditure.expenditureDate,
      lines,
      description: `${treatment === 'CAPITALIZE' ? '資本的支出' : '修繕費'} ${asset.assetName}`,
      reference: expenditure.expenditureId
    });
  }
}
```

---

## 6. 除却・売却処理

### 6.1 除却処理

```typescript
// ============================================================
// 資産除却サービス
// ============================================================

interface DisposalRequest {
  assetId: string;
  disposalDate: Date;
  disposalType: 'SCRAP' | 'SALE' | 'TRADE_IN' | 'DONATION';
  disposalReason: string;
  saleAmount?: Decimal;
  buyerId?: string;
  tradeInAssetId?: string;
  approvalId: string;
}

interface DisposalResult {
  assetId: string;
  disposalDate: Date;
  disposalType: string;
  finalBookValue: Decimal;
  saleAmount: Decimal;
  gainLoss: Decimal;
  gainLossType: 'GAIN' | 'LOSS' | 'NONE';
  journals: Journal[];
}

class AssetDisposalService {
  private depreciationEngine: DepreciationEngine;
  private journalGenerator: JournalGeneratorService;
  private taxDifferenceManager: TaxDifferenceManager;

  /**
   * 資産除却処理メイン
   */
  async disposeAsset(request: DisposalRequest): Promise<DisposalResult> {
    const asset = await this.assetRepository.findById(request.assetId);
    if (!asset) {
      throw new NotFoundError(`Asset ${request.assetId} not found`);
    }

    // 1. 除却日までの償却計算
    const finalDepreciation = await this.calculateFinalDepreciation(asset, request.disposalDate);

    // 2. 最終帳簿価額確定
    const finalBookValue = asset.accBookValue.minus(finalDepreciation.monthlyDepreciation);

    // 3. 売却損益計算
    const saleAmount = request.saleAmount || new Decimal(0);
    const gainLoss = saleAmount.minus(finalBookValue);
    const gainLossType = gainLoss.isPositive() ? 'GAIN' :
                         gainLoss.isNegative() ? 'LOSS' : 'NONE';

    // 4. 仕訳生成
    const journals: Journal[] = [];

    // 最終償却仕訳（期中除却の場合）
    if (finalDepreciation.monthlyDepreciation.isGreaterThan(0)) {
      journals.push(await this.generateFinalDepreciationJournal(asset, finalDepreciation));
    }

    // 除却仕訳
    journals.push(await this.generateDisposalJournal(asset, request, finalBookValue, gainLoss));

    // 5. 税務差異の解消
    await this.taxDifferenceManager.resolveOnDisposal(asset, request.disposalDate);

    // 6. 資産ステータス更新
    await this.assetRepository.update(request.assetId, {
      status: 'DISPOSED',
      disposalDate: request.disposalDate,
      disposalType: request.disposalType,
      disposalAmount: saleAmount
    });

    // 7. 監査ログ
    await this.auditLogger.log({
      action: 'ASSET_DISPOSAL',
      documentId: request.assetId,
      details: {
        disposalType: request.disposalType,
        finalBookValue: finalBookValue.toString(),
        saleAmount: saleAmount.toString(),
        gainLoss: gainLoss.toString()
      }
    });

    return {
      assetId: request.assetId,
      disposalDate: request.disposalDate,
      disposalType: request.disposalType,
      finalBookValue,
      saleAmount,
      gainLoss: gainLoss.abs(),
      gainLossType,
      journals
    };
  }

  /**
   * 除却仕訳生成
   */
  private async generateDisposalJournal(
    asset: FixedAsset,
    request: DisposalRequest,
    finalBookValue: Decimal,
    gainLoss: Decimal
  ): Promise<Journal> {
    const lines: JournalLine[] = [];
    let lineNo = 1;

    // 減価償却累計額の取崩
    if (asset.accAccumDepreciation.isGreaterThan(0)) {
      lines.push({
        lineNo: lineNo++,
        drCr: 'D',
        accountCode: this.getAccumDepreciationAccountCode(asset),
        amount: asset.accAccumDepreciation,
        taxCode: 'XX',
        description: `減価償却累計額取崩 ${asset.assetName}`,
        segmentPC: asset.segmentPc,
        segmentCC: asset.segmentCc
      });
    }

    // 売却の場合: 現金/売掛金
    if (request.disposalType === 'SALE' && request.saleAmount?.isGreaterThan(0)) {
      lines.push({
        lineNo: lineNo++,
        drCr: 'D',
        accountCode: request.buyerId ? '12100' : '11100',  // 売掛金 or 預金
        subAccountCode: request.buyerId,
        amount: request.saleAmount,
        taxCode: 'S10',  // 売却は課税売上
        description: `固定資産売却 ${asset.assetName}`
      });
    }

    // 売却損益
    if (gainLoss.isNegative()) {
      // 売却損/除却損
      const lossAccount = request.disposalType === 'SALE' ? '79520' : '79510';
      lines.push({
        lineNo: lineNo++,
        drCr: 'D',
        accountCode: lossAccount,
        amount: gainLoss.abs(),
        taxCode: 'XX',
        description: `固定資産${request.disposalType === 'SALE' ? '売却' : '除却'}損`,
        segmentPC: asset.segmentPc,
        segmentCC: asset.segmentCc
      });
    }

    // 固定資産の取崩
    lines.push({
      lineNo: lineNo++,
      drCr: 'C',
      accountCode: this.getAssetAccountCode(asset),
      amount: asset.acquisitionCost,
      taxCode: 'XX',
      description: `固定資産除却 ${asset.assetId}`,
      segmentPC: asset.segmentPc,
      segmentCC: asset.segmentCc
    });

    // 売却益
    if (gainLoss.isPositive()) {
      lines.push({
        lineNo: lineNo++,
        drCr: 'C',
        accountCode: '79510',  // 固定資産売却益
        amount: gainLoss,
        taxCode: 'XX',
        description: '固定資産売却益',
        segmentPC: asset.segmentPc,
        segmentCC: asset.segmentCc
      });
    }

    return await this.journalGenerator.generateJournal({
      journalType: 'ASSET_DISPOSAL',
      journalDate: request.disposalDate,
      lines,
      description: `固定資産${request.disposalType === 'SALE' ? '売却' : '除却'} ${asset.assetName}`,
      reference: request.assetId
    });
  }
}
```

---

## 7. 減損処理

### 7.1 減損判定・処理

```typescript
// ============================================================
// 減損処理サービス
// ============================================================

interface ImpairmentTest {
  assetGroupId: string;
  testDate: Date;
  carryingAmount: Decimal;           // 帳簿価額
  undiscountedCashFlow: Decimal;     // 割引前キャッシュフロー
  recoverableAmount: Decimal;        // 回収可能価額
  fairValueLessCost: Decimal;        // 正味売却価額
  valueInUse: Decimal;               // 使用価値
  impairmentRequired: boolean;
  impairmentLoss?: Decimal;
}

interface ImpairmentResult {
  assetGroupId: string;
  impairmentDate: Date;
  impairmentLoss: Decimal;
  allocationDetails: ImpairmentAllocation[];
  journal: Journal;
  taxEffect: TaxAccountingDifference;
}

interface ImpairmentAllocation {
  assetId: string;
  assetName: string;
  preImpairmentBookValue: Decimal;
  allocationAmount: Decimal;
  postImpairmentBookValue: Decimal;
}

class ImpairmentService {
  /**
   * 減損テスト実行
   */
  async performImpairmentTest(
    assetGroupId: string,
    testDate: Date,
    cashFlowProjection: CashFlowProjection
  ): Promise<ImpairmentTest> {
    // 資産グループの取得
    const assetGroup = await this.assetGroupRepository.findById(assetGroupId);
    const assets = await this.assetRepository.findByGroup(assetGroupId);

    // 帳簿価額の合計
    const carryingAmount = assets.reduce(
      (sum, a) => sum.plus(a.accBookValue),
      new Decimal(0)
    );

    // 割引前キャッシュフロー
    const undiscountedCashFlow = this.calculateUndiscountedCashFlow(cashFlowProjection);

    // 減損の兆候判定（割引前CFと帳簿価額の比較）
    if (undiscountedCashFlow.isGreaterThanOrEqualTo(carryingAmount)) {
      // 減損不要
      return {
        assetGroupId,
        testDate,
        carryingAmount,
        undiscountedCashFlow,
        recoverableAmount: new Decimal(0),
        fairValueLessCost: new Decimal(0),
        valueInUse: new Decimal(0),
        impairmentRequired: false
      };
    }

    // 回収可能価額の算定
    const fairValueLessCost = await this.estimateFairValueLessCost(assetGroup);
    const valueInUse = this.calculateValueInUse(cashFlowProjection, assetGroup.discountRate);
    const recoverableAmount = Decimal.max(fairValueLessCost, valueInUse);

    // 減損損失の計算
    const impairmentLoss = carryingAmount.minus(recoverableAmount);

    return {
      assetGroupId,
      testDate,
      carryingAmount,
      undiscountedCashFlow,
      recoverableAmount,
      fairValueLessCost,
      valueInUse,
      impairmentRequired: impairmentLoss.isPositive(),
      impairmentLoss: impairmentLoss.isPositive() ? impairmentLoss : undefined
    };
  }

  /**
   * 減損損失の配分
   */
  async allocateImpairmentLoss(
    test: ImpairmentTest
  ): Promise<ImpairmentResult> {
    if (!test.impairmentRequired || !test.impairmentLoss) {
      throw new ValidationError('Impairment is not required');
    }

    const assets = await this.assetRepository.findByGroup(test.assetGroupId);
    const totalBookValue = assets.reduce((sum, a) => sum.plus(a.accBookValue), new Decimal(0));

    // 帳簿価額比例で配分
    const allocations: ImpairmentAllocation[] = [];
    let remainingLoss = test.impairmentLoss;

    for (const asset of assets) {
      // 配分比率
      const ratio = asset.accBookValue.div(totalBookValue);
      let allocation = test.impairmentLoss.times(ratio).floor();

      // 帳簿価額を下回らないように調整
      const maxAllocation = asset.accBookValue.minus(asset.accResidualValue);
      allocation = Decimal.min(allocation, maxAllocation);

      allocations.push({
        assetId: asset.assetId,
        assetName: asset.assetName,
        preImpairmentBookValue: asset.accBookValue,
        allocationAmount: allocation,
        postImpairmentBookValue: asset.accBookValue.minus(allocation)
      });

      remainingLoss = remainingLoss.minus(allocation);
    }

    // 端数調整（最も帳簿価額が大きい資産に配分）
    if (!remainingLoss.isZero()) {
      const largestAsset = allocations.reduce((max, a) =>
        a.postImpairmentBookValue.isGreaterThan(max.postImpairmentBookValue) ? a : max
      );
      largestAsset.allocationAmount = largestAsset.allocationAmount.plus(remainingLoss);
      largestAsset.postImpairmentBookValue = largestAsset.postImpairmentBookValue.minus(remainingLoss);
    }

    // 資産の帳簿価額更新
    for (const allocation of allocations) {
      await this.assetRepository.update(allocation.assetId, {
        accBookValue: allocation.postImpairmentBookValue,
        impairmentLoss: allocation.allocationAmount,
        impairmentDate: test.testDate
      });
    }

    // 仕訳生成
    const journal = await this.generateImpairmentJournal(test, allocations);

    // 税効果計算
    const taxEffect = await this.taxDifferenceManager.calculateImpairmentTaxEffect(
      { assetId: test.assetGroupId } as FixedAsset,
      test.impairmentLoss
    );

    return {
      assetGroupId: test.assetGroupId,
      impairmentDate: test.testDate,
      impairmentLoss: test.impairmentLoss,
      allocationDetails: allocations,
      journal,
      taxEffect
    };
  }

  /**
   * 使用価値計算（DCF法）
   */
  private calculateValueInUse(
    projection: CashFlowProjection,
    discountRate: Decimal
  ): Decimal {
    let pv = new Decimal(0);

    for (let i = 0; i < projection.years.length; i++) {
      const cashFlow = projection.years[i].netCashFlow;
      const discountFactor = new Decimal(1).div(
        new Decimal(1).plus(discountRate).pow(i + 1)
      );
      pv = pv.plus(cashFlow.times(discountFactor));
    }

    // 残存価値の現在価値を加算
    if (projection.terminalValue) {
      const years = projection.years.length;
      const terminalDiscountFactor = new Decimal(1).div(
        new Decimal(1).plus(discountRate).pow(years)
      );
      pv = pv.plus(projection.terminalValue.times(terminalDiscountFactor));
    }

    return pv;
  }
}
```

---

## 8. 有価証券管理

### 8.1 有価証券評価

```typescript
// ============================================================
// 有価証券評価サービス
// ============================================================

interface SecurityValuationResult {
  securityHoldingId: string;
  valuationDate: Date;
  holdingPurpose: SecurityHoldingPurpose;
  acquisitionCost: Decimal;
  fairValue: Decimal;
  valuationDifference: Decimal;
  accountingTreatment: ValuationTreatment;
  journalRequired: boolean;
  journal?: Journal;
}

type SecurityHoldingPurpose = 'TRADE' | 'HTM' | 'AFS' | 'SUBSIDIARY';

type ValuationTreatment =
  | 'PL_FV'           // P/L時価評価（売買目的）
  | 'OCI_FV'          // OCI時価評価（その他有価証券）
  | 'AMORTIZED_COST'  // 償却原価（満期保有目的）
  | 'COST'            // 原価法（子会社等）
  | 'IMPAIRMENT';     // 減損

class SecuritiesValuationService {
  /**
   * 期末評価処理
   */
  async performEndOfPeriodValuation(
    valuationDate: Date
  ): Promise<SecurityValuationResult[]> {
    const holdings = await this.securitiesRepository.findActiveHoldings();
    const results: SecurityValuationResult[] = [];

    for (const holding of holdings) {
      const result = await this.valuateHolding(holding, valuationDate);
      results.push(result);
    }

    return results;
  }

  /**
   * 個別銘柄の評価
   */
  async valuateHolding(
    holding: SecurityHolding,
    valuationDate: Date
  ): Promise<SecurityValuationResult> {
    // 時価取得
    const fairValue = await this.getFairValue(holding.securityCode, valuationDate);

    // 保有目的に応じた評価処理
    switch (holding.holdingPurpose) {
      case 'TRADE':
        return this.valuateTrading(holding, fairValue, valuationDate);

      case 'HTM':
        return this.valuateHeldToMaturity(holding, valuationDate);

      case 'AFS':
        return this.valuateAvailableForSale(holding, fairValue, valuationDate);

      case 'SUBSIDIARY':
        return this.valuateSubsidiary(holding, fairValue, valuationDate);

      default:
        throw new Error(`Unknown holding purpose: ${holding.holdingPurpose}`);
    }
  }

  /**
   * 売買目的有価証券の評価（時価評価→P/L計上）
   */
  private async valuateTrading(
    holding: SecurityHolding,
    fairValue: Decimal,
    valuationDate: Date
  ): SecurityValuationResult {
    const valuationDiff = fairValue.minus(holding.bookValue);

    let journal: Journal | undefined;
    if (!valuationDiff.isZero()) {
      const lines: JournalLine[] = [];

      if (valuationDiff.isPositive()) {
        // 評価益
        lines.push({
          lineNo: 1,
          drCr: 'D',
          accountCode: '13010',  // 有価証券
          subAccountCode: holding.securityCode,
          amount: valuationDiff,
          taxCode: 'XX',
          description: `有価証券評価益 ${holding.securityName}`
        });
        lines.push({
          lineNo: 2,
          drCr: 'C',
          accountCode: '79310',  // 有価証券評価益
          amount: valuationDiff,
          taxCode: 'XX',
          description: `売買目的有価証券評価益`
        });
      } else {
        // 評価損
        lines.push({
          lineNo: 1,
          drCr: 'D',
          accountCode: '79320',  // 有価証券評価損
          amount: valuationDiff.abs(),
          taxCode: 'XX',
          description: `売買目的有価証券評価損`
        });
        lines.push({
          lineNo: 2,
          drCr: 'C',
          accountCode: '13010',
          subAccountCode: holding.securityCode,
          amount: valuationDiff.abs(),
          taxCode: 'XX',
          description: `有価証券評価損 ${holding.securityName}`
        });
      }

      journal = await this.journalGenerator.generateJournal({
        journalType: 'SECURITY_VALUATION',
        journalDate: valuationDate,
        lines,
        description: `売買目的有価証券期末評価 ${holding.securityCode}`
      });
    }

    return {
      securityHoldingId: holding.securityHoldingId,
      valuationDate,
      holdingPurpose: 'TRADE',
      acquisitionCost: holding.acquisitionCost,
      fairValue,
      valuationDifference: valuationDiff,
      accountingTreatment: 'PL_FV',
      journalRequired: !valuationDiff.isZero(),
      journal
    };
  }

  /**
   * その他有価証券の評価（時価評価→OCI計上）
   */
  private async valuateAvailableForSale(
    holding: SecurityHolding,
    fairValue: Decimal,
    valuationDate: Date
  ): SecurityValuationResult {
    const valuationDiff = fairValue.minus(holding.acquisitionCost);

    // 減損判定（50%以上下落で減損）
    if (fairValue.isLessThan(holding.acquisitionCost.times(0.5))) {
      return this.recordImpairment(holding, fairValue, valuationDate);
    }

    // 税効果考慮後の評価差額
    const effectiveTaxRate = new Decimal(0.3);
    const taxEffect = valuationDiff.times(effectiveTaxRate);
    const netValuationDiff = valuationDiff.minus(taxEffect);

    let journal: Journal | undefined;
    if (!valuationDiff.isZero()) {
      const lines: JournalLine[] = [];

      if (valuationDiff.isPositive()) {
        // 評価差額（借方：有価証券、貸方：その他有価証券評価差額金）
        lines.push({
          lineNo: 1,
          drCr: 'D',
          accountCode: '13020',  // 投資有価証券
          subAccountCode: holding.securityCode,
          amount: valuationDiff,
          taxCode: 'XX',
          description: `その他有価証券評価差額 ${holding.securityName}`
        });
        // 繰延税金負債
        lines.push({
          lineNo: 2,
          drCr: 'C',
          accountCode: '25100',  // 繰延税金負債
          amount: taxEffect,
          taxCode: 'XX',
          description: '繰延税金負債（その他有価証券）'
        });
        // その他有価証券評価差額金
        lines.push({
          lineNo: 3,
          drCr: 'C',
          accountCode: '33100',  // その他有価証券評価差額金
          amount: netValuationDiff,
          taxCode: 'XX',
          description: 'その他有価証券評価差額金'
        });
      } else {
        // 評価差額（マイナス）
        lines.push({
          lineNo: 1,
          drCr: 'D',
          accountCode: '33100',
          amount: netValuationDiff.abs(),
          taxCode: 'XX',
          description: 'その他有価証券評価差額金'
        });
        lines.push({
          lineNo: 2,
          drCr: 'D',
          accountCode: '18100',  // 繰延税金資産
          amount: taxEffect.abs(),
          taxCode: 'XX',
          description: '繰延税金資産（その他有価証券）'
        });
        lines.push({
          lineNo: 3,
          drCr: 'C',
          accountCode: '13020',
          subAccountCode: holding.securityCode,
          amount: valuationDiff.abs(),
          taxCode: 'XX',
          description: `その他有価証券評価差額 ${holding.securityName}`
        });
      }

      journal = await this.journalGenerator.generateJournal({
        journalType: 'SECURITY_VALUATION',
        journalDate: valuationDate,
        lines,
        description: `その他有価証券期末評価 ${holding.securityCode}`
      });
    }

    return {
      securityHoldingId: holding.securityHoldingId,
      valuationDate,
      holdingPurpose: 'AFS',
      acquisitionCost: holding.acquisitionCost,
      fairValue,
      valuationDifference: valuationDiff,
      accountingTreatment: 'OCI_FV',
      journalRequired: !valuationDiff.isZero(),
      journal
    };
  }

  /**
   * 満期保有目的債券の評価（償却原価法）
   */
  private async valuateHeldToMaturity(
    holding: SecurityHolding,
    valuationDate: Date
  ): SecurityValuationResult {
    if (holding.securityType !== 'BOND') {
      throw new ValidationError('HTM is only applicable to bonds');
    }

    // 償却原価の計算（利息法）
    const amortization = this.calculateBondAmortization(holding, valuationDate);

    let journal: Journal | undefined;
    if (!amortization.currentPeriodAmortization.isZero()) {
      const lines: JournalLine[] = [];

      // 利息収入
      lines.push({
        lineNo: 1,
        drCr: 'D',
        accountCode: '13020',  // 投資有価証券
        subAccountCode: holding.securityCode,
        amount: amortization.currentPeriodAmortization,
        taxCode: 'XX',
        description: `債券償却原価調整 ${holding.securityName}`
      });
      lines.push({
        lineNo: 2,
        drCr: 'C',
        accountCode: '81100',  // 有価証券利息
        amount: amortization.currentPeriodAmortization,
        taxCode: 'XX',
        description: '債券利息（償却原価調整）'
      });

      journal = await this.journalGenerator.generateJournal({
        journalType: 'BOND_AMORTIZATION',
        journalDate: valuationDate,
        lines,
        description: `満期保有目的債券償却原価調整 ${holding.securityCode}`
      });
    }

    return {
      securityHoldingId: holding.securityHoldingId,
      valuationDate,
      holdingPurpose: 'HTM',
      acquisitionCost: holding.acquisitionCost,
      fairValue: amortization.amortizedCost,
      valuationDifference: amortization.amortizedCost.minus(holding.acquisitionCost),
      accountingTreatment: 'AMORTIZED_COST',
      journalRequired: !amortization.currentPeriodAmortization.isZero(),
      journal
    };
  }
}
```

---

## 9. 帳票・レポート

### 9.1 固定資産台帳出力項目

| 出力項目 | データソース | 形式 |
|----------|--------------|------|
| 資産番号 | asset_id | VARCHAR |
| 資産名称 | asset_name | VARCHAR |
| 資産区分 | asset_category + 名称 | VARCHAR |
| 取得日 | acquisition_date | DATE |
| 稼働日 | service_start_date | DATE |
| 取得原価 | acquisition_cost | DECIMAL |
| 耐用年数 | acc_useful_life_months / 12 | INT |
| 償却方法 | acc_depreciation_method名称 | VARCHAR |
| 期首帳簿価額 | 計算値 | DECIMAL |
| 当期償却額 | 計算値 | DECIMAL |
| 期末帳簿価額 | acc_book_value | DECIMAL |
| 償却累計額 | acc_accum_depreciation | DECIMAL |
| 設置場所 | location_name | VARCHAR |
| 管理部門 | dept_code + 名称 | VARCHAR |
| セグメント | segment_pc/cc/prj | VARCHAR |

### 9.2 償却明細書

```typescript
// ============================================================
// 償却明細書生成
// ============================================================

interface DepreciationScheduleReport {
  fiscalYear: string;
  reportDate: Date;
  summary: DepreciationSummary;
  byCategory: CategoryDepreciation[];
  byDepartment: DepartmentDepreciation[];
  bySegment: SegmentDepreciation[];
  details: AssetDepreciationDetail[];
}

interface DepreciationSummary {
  totalAssets: number;
  totalAcquisitionCost: Decimal;
  totalBeginningBookValue: Decimal;
  totalDepreciation: Decimal;
  totalEndingBookValue: Decimal;
  accountingDepreciation: Decimal;
  taxDepreciation: Decimal;
  taxDifference: Decimal;
}

class DepreciationReportService {
  /**
   * 償却明細書生成
   */
  async generateDepreciationSchedule(
    fiscalYear: string,
    options: ReportOptions
  ): Promise<DepreciationScheduleReport> {
    const assets = await this.assetRepository.findActiveAssets(fiscalYear);
    const depreciationRecords = await this.depreciationRepository.findByFiscalYear(fiscalYear);

    // サマリー集計
    const summary = this.calculateSummary(assets, depreciationRecords);

    // 資産区分別集計
    const byCategory = this.aggregateByCategory(assets, depreciationRecords);

    // 部門別集計
    const byDepartment = this.aggregateByDepartment(assets, depreciationRecords);

    // セグメント別集計
    const bySegment = this.aggregateBySegment(assets, depreciationRecords);

    // 明細
    const details = this.generateDetails(assets, depreciationRecords);

    return {
      fiscalYear,
      reportDate: new Date(),
      summary,
      byCategory,
      byDepartment,
      bySegment,
      details
    };
  }

  /**
   * 法人税申告用別表十六出力
   */
  async generateTaxSchedule16(
    fiscalYear: string
  ): Promise<TaxSchedule16> {
    const assets = await this.assetRepository.findActiveAssets(fiscalYear);
    const taxDepreciationRecords = await this.depreciationRepository.findTaxByFiscalYear(fiscalYear);

    // 別表十六（一）：定額法
    const schedule16_1 = this.generateSchedule16_1(
      assets.filter(a => a.taxDepreciationMethod === 'SL'),
      taxDepreciationRecords
    );

    // 別表十六（二）：定率法
    const schedule16_2 = this.generateSchedule16_2(
      assets.filter(a => ['DB', 'DB250', 'DB200'].includes(a.taxDepreciationMethod)),
      taxDepreciationRecords
    );

    return {
      fiscalYear,
      schedule16_1,
      schedule16_2,
      totalDepreciationLimit: schedule16_1.total.plus(schedule16_2.total),
      actualDepreciation: this.calculateActualDepreciation(taxDepreciationRecords),
      excessDepreciation: this.calculateExcessDepreciation(taxDepreciationRecords)
    };
  }
}
```

---

## 10. 更新履歴

| 版数 | 更新日 | 更新者 | 更新内容 |
|------|--------|--------|----------|
| 1.0 | 2025/01/08 | システム設計チーム | 初版作成 |

---

## 【レビューチェックリスト】

- [ ] 資産区分と耐用年数が税法に準拠しているか
- [ ] 定額法・定率法の計算が正確か
- [ ] 償却保証額・改定償却率が最新の税法と一致しているか
- [ ] 初年度・最終年度の月割計算が正しいか
- [ ] 会計と税務の差異が管理できるか
- [ ] IFRSコンポーネントアプローチに対応しているか
- [ ] 除却処理の仕訳が正しいか
- [ ] 減損処理が会計基準に準拠しているか
- [ ] 有価証券の評価方法が適切か
- [ ] 不動産（物件ユニット）との連携が考慮されているか
- [ ] セグメント別の償却費集計ができるか
- [ ] J-SOX統制要件を満たしているか
- [ ] 税務担当者のレビューを受けているか
