"""TypeScript type definition generator for The Mesh."""


class TypeScriptGenerator:
    """Generate TypeScript type definitions from TRIR specification.

    Generates:
    - Entity interfaces
    - Function input/output types
    - Enum type aliases
    """

    def __init__(self, spec: dict):
        self.spec = spec
        self.entities = spec.get("state", {})
        self.functions = spec.get("functions", {})
        self.derived = spec.get("derived", {})

    def generate_all(self) -> str:
        """Generate all TypeScript type definitions."""
        sections = []

        # Header
        sections.append("// Generated by The Mesh - Do not edit manually")
        sections.append("")

        # Enum types (extracted from entity fields)
        enums = self._generate_enum_types()
        if enums:
            sections.append("// Enum Types")
            sections.append(enums)

        # Entity interfaces
        entities = self._generate_entity_types()
        if entities:
            sections.append("// Entity Types")
            sections.append(entities)

        # Function input types
        func_inputs = self._generate_function_input_types()
        if func_inputs:
            sections.append("// Function Input Types")
            sections.append(func_inputs)

        # Function output types
        func_outputs = self._generate_function_output_types()
        if func_outputs:
            sections.append("// Function Output Types")
            sections.append(func_outputs)

        # Error types
        errors = self._generate_error_types()
        if errors:
            sections.append("// Error Types")
            sections.append(errors)

        return "\n".join(sections)

    def generate_for_entity(self, entity_name: str) -> str:
        """Generate TypeScript types for a specific entity."""
        if entity_name not in self.entities:
            return f"// Entity not found: {entity_name}"

        entity = self.entities[entity_name]
        return self._generate_entity_interface(entity_name, entity)

    def generate_for_function(self, function_name: str) -> str:
        """Generate TypeScript types for a specific function."""
        if function_name not in self.functions:
            return f"// Function not found: {function_name}"

        func = self.functions[function_name]
        lines = []

        # Input type
        input_def = func.get("input", {})
        if input_def:
            lines.append(self._generate_function_input_interface(function_name, input_def))

        # Output type
        output_def = func.get("output", {})
        if output_def:
            lines.append(self._generate_function_output_interface(function_name, output_def))

        return "\n".join(lines)

    def _generate_enum_types(self) -> str:
        """Generate enum type aliases from entity fields."""
        enums = {}

        # Extract enums from entity fields
        for entity_name, entity in self.entities.items():
            for field_name, field_def in entity.get("fields", {}).items():
                field_type = field_def.get("type")
                if isinstance(field_type, dict) and "enum" in field_type:
                    # Create enum name from entity and field
                    enum_name = f"{self._to_pascal_case(entity_name)}{self._to_pascal_case(field_name)}"
                    if enum_name not in enums:
                        enums[enum_name] = field_type["enum"]

        if not enums:
            return ""

        lines = []
        for enum_name, values in enums.items():
            values_str = " | ".join(f"'{v}'" for v in values)
            lines.append(f"export type {enum_name} = {values_str};")
        lines.append("")

        return "\n".join(lines)

    def _generate_entity_types(self) -> str:
        """Generate TypeScript interfaces for all entities."""
        lines = []

        for entity_name, entity in self.entities.items():
            lines.append(self._generate_entity_interface(entity_name, entity))
            lines.append("")

        return "\n".join(lines)

    def _generate_entity_interface(self, entity_name: str, entity: dict) -> str:
        """Generate a single entity interface."""
        pascal_name = self._to_pascal_case(entity_name)
        lines = []

        # Add description as JSDoc if present
        if "description" in entity:
            lines.append(f"/** {entity['description']} */")

        lines.append(f"export interface {pascal_name} {{")

        fields = entity.get("fields", {})
        for field_name, field_def in fields.items():
            ts_type = self._get_ts_type(field_def)
            optional = "" if field_def.get("required", True) else "?"

            # Add field description as inline comment
            desc = field_def.get("description", "")
            if desc:
                lines.append(f"  /** {desc} */")

            lines.append(f"  {field_name}{optional}: {ts_type};")

        lines.append("}")

        return "\n".join(lines)

    def _generate_function_input_types(self) -> str:
        """Generate TypeScript interfaces for function inputs."""
        lines = []

        for func_name, func in self.functions.items():
            input_def = func.get("input", {})
            if input_def:
                lines.append(self._generate_function_input_interface(func_name, input_def))
                lines.append("")

        return "\n".join(lines)

    def _generate_function_input_interface(self, func_name: str, input_def: dict) -> str:
        """Generate a single function input interface."""
        pascal_name = self._to_pascal_case(func_name)
        lines = []

        lines.append(f"export interface {pascal_name}Input {{")

        for param_name, param_def in input_def.items():
            ts_type = self._get_ts_type(param_def)
            optional = "" if param_def.get("required", True) else "?"
            lines.append(f"  {param_name}{optional}: {ts_type};")

        lines.append("}")

        return "\n".join(lines)

    def _generate_function_output_types(self) -> str:
        """Generate TypeScript interfaces for function outputs."""
        lines = []

        for func_name, func in self.functions.items():
            output_def = func.get("output", {})
            if output_def:
                lines.append(self._generate_function_output_interface(func_name, output_def))
                lines.append("")

        return "\n".join(lines)

    def _generate_function_output_interface(self, func_name: str, output_def: dict) -> str:
        """Generate a single function output interface."""
        pascal_name = self._to_pascal_case(func_name)
        lines = []

        lines.append(f"export interface {pascal_name}Output {{")

        for field_name, field_def in output_def.items():
            ts_type = self._get_ts_type(field_def)
            optional = "" if field_def.get("required", True) else "?"
            lines.append(f"  {field_name}{optional}: {ts_type};")

        lines.append("}")

        return "\n".join(lines)

    def _generate_error_types(self) -> str:
        """Generate TypeScript types for function errors."""
        error_codes = set()

        for func in self.functions.values():
            for error in func.get("error", []):
                code = error.get("code")
                if code:
                    error_codes.add(code)

        if not error_codes:
            return ""

        lines = []

        # Error code union type
        codes_str = " | ".join(f"'{code}'" for code in sorted(error_codes))
        lines.append(f"export type ErrorCode = {codes_str};")
        lines.append("")

        # Error response interface
        lines.append("export interface ErrorResponse {")
        lines.append("  success: false;")
        lines.append("  error: ErrorCode;")
        lines.append("  message?: string;")
        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _get_ts_type(self, field_def: dict) -> str:
        """Convert TRIR field type to TypeScript type."""
        field_type = field_def.get("type")

        if isinstance(field_type, str):
            type_map = {
                "string": "string",
                "int": "number",
                "float": "number",
                "bool": "boolean",
                "datetime": "string",
                "text": "string"
            }
            return type_map.get(field_type, "unknown")

        if isinstance(field_type, dict):
            if "enum" in field_type:
                values = " | ".join(f"'{v}'" for v in field_type["enum"])
                return values
            if "ref" in field_type:
                # Return the referenced entity type for better type safety
                ref_entity = field_type["ref"]
                return f"string  // references {self._to_pascal_case(ref_entity)}"
            if "list" in field_type:
                inner = self._get_ts_type({"type": field_type["list"]})
                # Remove comment from inner type if present
                inner = inner.split("//")[0].strip()
                return f"{inner}[]"

        return "unknown"

    def _to_pascal_case(self, name: str) -> str:
        """Convert snake_case to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _to_camel_case(self, name: str) -> str:
        """Convert snake_case to camelCase."""
        parts = name.split("_")
        return parts[0] + "".join(word.capitalize() for word in parts[1:])
