"""Zod validation schema generator for The Mesh."""

from typing import Any


class ZodGenerator:
    """Generate Zod validation schemas from TRIR specification.

    Generates:
    - Entity schemas
    - Function input schemas with refinements
    - Type exports
    """

    def __init__(self, spec: dict):
        self.spec = spec
        self.entities = spec.get("entities", {})
        self.functions = spec.get("commands", {})
        self.derived = spec.get("derived", {})

    def generate_all(self) -> str:
        """Generate all Zod schemas."""
        sections = []

        # Header and imports
        sections.append("// Generated by The Mesh - Do not edit manually")
        sections.append("import { z } from 'zod';")
        sections.append("")

        # Entity schemas
        entity_schemas = self._generate_entity_schemas()
        if entity_schemas:
            sections.append("// Entity Schemas")
            sections.append(entity_schemas)

        # Function input schemas
        func_schemas = self._generate_function_input_schemas()
        if func_schemas:
            sections.append("// Function Input Schemas")
            sections.append(func_schemas)

        # Type exports
        type_exports = self._generate_type_exports()
        if type_exports:
            sections.append("// Type Exports")
            sections.append(type_exports)

        return "\n".join(sections)

    def generate_for_entity(self, entity_name: str) -> str:
        """Generate Zod schema for a specific entity."""
        if entity_name not in self.entities:
            return f"// Entity not found: {entity_name}"

        entity = self.entities[entity_name]
        return self._generate_entity_schema(entity_name, entity)

    def generate_for_function(self, function_name: str) -> str:
        """Generate Zod schema for a specific function input."""
        if function_name not in self.functions:
            return f"// Function not found: {function_name}"

        func = self.functions[function_name]
        return self._generate_function_input_schema(function_name, func)

    def _generate_entity_schemas(self) -> str:
        """Generate Zod schemas for all entities."""
        lines = []

        for entity_name, entity in self.entities.items():
            lines.append(self._generate_entity_schema(entity_name, entity))
            lines.append("")

        return "\n".join(lines)

    def _generate_entity_schema(self, entity_name: str, entity: dict) -> str:
        """Generate a single entity schema."""
        camel_name = self._to_camel_case(entity_name)
        lines = []

        # Add description as comment if present
        if "description" in entity:
            lines.append(f"/** {entity['description']} */")

        lines.append(f"export const {camel_name}Schema = z.object({{")

        fields = entity.get("fields", {})
        for field_name, field_def in fields.items():
            zod_type = self._trir_type_to_zod(field_def)
            optional = not field_def.get("required", True)

            if optional:
                zod_type += ".optional()"

            # Add comment for description
            desc = field_def.get("description", "")
            if desc:
                lines.append(f"  // {desc}")

            lines.append(f"  {field_name}: {zod_type},")

        lines.append("});")

        return "\n".join(lines)

    def _generate_function_input_schemas(self) -> str:
        """Generate Zod schemas for all function inputs."""
        lines = []

        for func_name, func in self.functions.items():
            schema = self._generate_function_input_schema(func_name, func)
            if schema:
                lines.append(schema)
                lines.append("")

        return "\n".join(lines)

    def _generate_function_input_schema(self, func_name: str, func: dict) -> str:
        """Generate Zod schema for a function input with refinements."""
        input_def = func.get("input", {})
        if not input_def:
            return ""

        camel_name = self._to_camel_case(func_name)
        lines = []

        # Add description as comment
        if "description" in func:
            lines.append(f"/** {func['description']} */")

        lines.append(f"export const {camel_name}InputSchema = z.object({{")

        for param_name, param_def in input_def.items():
            zod_type = self._trir_type_to_zod(param_def)
            optional = not param_def.get("required", True)

            if optional:
                zod_type += ".optional()"

            lines.append(f"  {param_name}: {zod_type},")

        lines.append("})")

        # Add refinements from pre conditions
        refinements = self._extract_refinements(func)
        if refinements:
            for refinement in refinements:
                lines.append(refinement)

        # Add comments for server-side-only validations
        server_only = self._extract_server_only_validations(func)
        if server_only:
            lines.append("")
            for comment in server_only:
                lines.append(comment)

        lines.append(";")

        return "\n".join(lines)

    def _extract_refinements(self, func: dict) -> list[str]:
        """Extract frontend-compatible refinements from pre conditions."""
        refinements = []

        for pre in func.get("pre", []):
            expr = pre.get("expr", pre.get("check", {}))
            reason = pre.get("reason", "Validation failed")

            refinement = self._expr_to_refinement(expr, reason)
            if refinement:
                refinements.append(refinement)

        return refinements

    def _expr_to_refinement(self, expr: dict, reason: str) -> str | None:
        """Convert TRIR expression to Zod refinement.

        Only converts expressions that can be validated on frontend:
        - Comparisons between input fields and literals
        - Simple arithmetic comparisons
        """
        if not expr or not isinstance(expr, dict):
            return None

        expr_type = expr.get("type")

        if expr_type == "binary":
            return self._binary_to_refinement(expr, reason)

        # Other expression types need server-side validation
        return None

    def _binary_to_refinement(self, expr: dict, reason: str) -> str | None:
        """Convert binary expression to Zod refinement."""
        op = expr.get("op")
        left = expr.get("left", {})
        right = expr.get("right", {})

        # Only handle input field vs literal comparisons
        left_ref = self._get_input_ref(left)
        right_ref = self._get_input_ref(right)

        left_literal = self._get_literal(left)
        right_literal = self._get_literal(right)

        # input.field op literal
        if left_ref and right_literal is not None:
            op_map = {
                "gt": ">",
                "ge": ">=",
                "lt": "<",
                "le": "<=",
                "eq": "===",
                "ne": "!=="
            }
            if op in op_map:
                js_op = op_map[op]
                return f".refine(data => data.{left_ref} {js_op} {self._to_js_literal(right_literal)}, {{ message: \"{reason}\", path: [\"{left_ref}\"] }})"

        # literal op input.field (swap operands)
        if right_ref and left_literal is not None:
            op_map_reversed = {
                "gt": "<",
                "ge": "<=",
                "lt": ">",
                "le": ">=",
                "eq": "===",
                "ne": "!=="
            }
            if op in op_map_reversed:
                js_op = op_map_reversed[op]
                return f".refine(data => data.{right_ref} {js_op} {self._to_js_literal(left_literal)}, {{ message: \"{reason}\", path: [\"{right_ref}\"] }})"

        # input.field1 op input.field2
        if left_ref and right_ref:
            op_map = {
                "gt": ">",
                "ge": ">=",
                "lt": "<",
                "le": "<=",
                "eq": "===",
                "ne": "!=="
            }
            if op in op_map:
                js_op = op_map[op]
                return f".refine(data => data.{left_ref} {js_op} data.{right_ref}, {{ message: \"{reason}\" }})"

        return None

    def _get_input_ref(self, expr: dict) -> str | None:
        """Get input parameter name from expression."""
        if expr.get("type") == "input":
            return expr.get("name")
        return None

    def _get_literal(self, expr: dict) -> Any:
        """Get literal value from expression."""
        if expr.get("type") == "literal":
            return expr.get("value")
        return None

    def _extract_server_only_validations(self, func: dict) -> list[str]:
        """Extract validations that require server-side checking."""
        comments = []

        for pre in func.get("pre", []):
            expr = pre.get("expr", pre.get("check", {}))
            reason = pre.get("reason", "")

            if self._requires_server_validation(expr):
                desc = self._expr_to_description(expr)
                comment = f"// Server-side validation: {desc}"
                if reason:
                    comment += f" ({reason})"
                comments.append(comment)

        # Error conditions that check entity state
        for error in func.get("error", []):
            expr = error.get("when", {})
            if self._requires_server_validation(expr):
                code = error.get("code", "")
                reason = error.get("reason", "")
                desc = self._expr_to_description(expr)
                comment = f"// Server-side error check [{code}]: {desc}"
                if reason:
                    comment += f" ({reason})"
                comments.append(comment)

        return comments

    def _requires_server_validation(self, expr: dict) -> bool:
        """Check if expression requires server-side validation."""
        if not expr or not isinstance(expr, dict):
            return False

        expr_type = expr.get("type")

        # Entity references need server-side lookup
        if expr_type == "ref":
            return True

        # Aggregations need database access
        if expr_type == "agg":
            return True

        # Function calls need server execution
        if expr_type == "call":
            return True

        # State operations need entity state
        if expr_type == "state":
            return True

        # Check nested expressions
        if expr_type == "binary":
            left = expr.get("left", {})
            right = expr.get("right", {})
            return self._requires_server_validation(left) or self._requires_server_validation(right)

        if expr_type == "unary":
            return self._requires_server_validation(expr.get("expr", {}))

        return False

    def _expr_to_description(self, expr: dict) -> str:
        """Convert expression to human-readable description."""
        if not expr or not isinstance(expr, dict):
            return "unknown"

        expr_type = expr.get("type")

        if expr_type == "literal":
            return str(expr.get("value"))

        if expr_type == "input":
            return f"input.{expr.get('name')}"

        if expr_type == "ref":
            return expr.get("path", "")

        if expr_type == "binary":
            op_map = {
                "eq": "==", "ne": "!=",
                "gt": ">", "ge": ">=",
                "lt": "<", "le": "<=",
                "and": "&&", "or": "||"
            }
            op = op_map.get(expr.get("op"), expr.get("op"))
            left = self._expr_to_description(expr.get("left", {}))
            right = self._expr_to_description(expr.get("right", {}))
            return f"{left} {op} {right}"

        if expr_type == "agg":
            op = expr.get("op")
            from_entity = expr.get("from")
            return f"{op}({from_entity})"

        if expr_type == "call":
            return f"{expr.get('name')}()"

        return f"<{expr_type}>"

    def _generate_type_exports(self) -> str:
        """Generate TypeScript type exports from Zod schemas."""
        lines = []

        # Entity types
        for entity_name in self.entities:
            camel_name = self._to_camel_case(entity_name)
            pascal_name = self._to_pascal_case(entity_name)
            lines.append(f"export type {pascal_name} = z.infer<typeof {camel_name}Schema>;")

        # Function input types
        for func_name in self.functions:
            func = self.functions[func_name]
            if func.get("input"):
                camel_name = self._to_camel_case(func_name)
                pascal_name = self._to_pascal_case(func_name)
                lines.append(f"export type {pascal_name}Input = z.infer<typeof {camel_name}InputSchema>;")

        return "\n".join(lines)

    def _trir_type_to_zod(self, field_def: dict) -> str:
        """Convert TRIR field type to Zod schema."""
        field_type = field_def.get("type")

        if isinstance(field_type, str):
            type_map = {
                "string": "z.string().min(1)",
                "int": "z.number().int()",
                "float": "z.number()",
                "bool": "z.boolean()",
                "datetime": "z.string().datetime()",
                "text": "z.string()"
            }
            return type_map.get(field_type, "z.unknown()")

        if isinstance(field_type, dict):
            if "enum" in field_type:
                values = ", ".join(f"'{v}'" for v in field_type["enum"])
                return f"z.enum([{values}])"
            if "ref" in field_type:
                # Reference is just a string ID
                ref_entity = field_type["ref"]
                return f"z.string().min(1)  // references {self._to_pascal_case(ref_entity)}"
            if "list" in field_type:
                inner = self._trir_type_to_zod({"type": field_type["list"]})
                # Remove comment from inner type if present
                inner = inner.split("//")[0].strip()
                return f"z.array({inner})"

        return "z.unknown()"

    def _to_js_literal(self, value: Any) -> str:
        """Convert Python value to JavaScript literal."""
        if value is None:
            return "null"
        if value is True:
            return "true"
        if value is False:
            return "false"
        if isinstance(value, str):
            return f"'{value}'"
        if isinstance(value, (int, float)):
            return str(value)
        return str(value)

    def _to_pascal_case(self, name: str) -> str:
        """Convert snake_case to PascalCase."""
        return "".join(word.capitalize() for word in name.split("_"))

    def _to_camel_case(self, name: str) -> str:
        """Convert snake_case to camelCase."""
        parts = name.split("_")
        return parts[0] + "".join(word.capitalize() for word in parts[1:])
